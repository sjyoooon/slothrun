<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>Beam Run</title>
  <style>
    :root { --bg:#ffffff; }

    /* Prevent selection/scroll/zoom gestures; whole page is input surface */
    html, body {
      margin: 0;
      height: 100%;
      background: var(--bg);
      overflow: hidden;           /* no page scroll */
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;         /* disable browser gestures */
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans", Arial, sans-serif;
    }

    * { box-sizing: border-box; }

    .wrap {
      position: relative;
      width: min(960px, 100vw);
      margin: 0 auto;
      padding: 12px;
      display: grid;
      place-items: center;
      height: 100dvh;
    }

    .game-container {
      position: relative;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0;
    }

    canvas {
      width: 100%;
      height: auto;
      display: block;
      background: #fff;
      touch-action: none;       /* ensure pointer events go to game */
      user-select: none;
    }

    .hud {
      pointer-events: none;
      position: absolute;
      top: 0; left: 0; right: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-weight: 700; font-variant-numeric: tabular-nums;
      z-index: 10;
    }
    .badge {
      background: transparent;
      padding: 6px 10px;
    }

    /* Score popup animation */
    @keyframes scorePopup {
      0% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.2);
      }
      100% {
        transform: scale(1);
      }
    }

    .score-popup {
      animation: scorePopup 0.3s ease-out;
    }

    #overlay {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      top: 0;
      display: none;
      align-items: flex-end;
      justify-content: center;
      pointer-events: none;
    }
    #restartBtn {
      appearance: none; border: 0; border-radius: 10px;
      background: #111; color: #fff; font-weight: 700; cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,.15);
      display: inline-grid; place-items: center;
      pointer-events: auto;
      position: relative;
    }
    #restartBtn:active { transform: translateY(1px); }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="game-container">
      <div class="hud">
        <div id="highScore" class="badge">HIGH SCORE: 0</div>
        <div id="score" class="badge">SCORE: 0</div>
      </div>

      <canvas id="game" width="900" height="600" aria-label="Beam Run"></canvas>

      <div id="overlay">
        <button id="restartBtn" aria-label="Restart">Restart</button>
      </div>
    </div>
  </div>

  <script>
    // ===============================
    // CONFIG ‚Äî tweak freely
    // ===============================
    const CONFIG = {
      GAME_WIDTH: 800,
      GAME_HEIGHT: 1000,

      // Player / ground
      GROUND_Y: 500,
      GROUND_LINE_WIDTH: 2,    // px (ground line thickness)
      DINO_X: 60,
      DINO_WIDTH: 72,
      DINO_HEIGHT: 84,

      // Character hitbox (rectangle collision for character)
      // Values are relative to character position (0 = left/top edge)
      DINO_HITBOX_OFFSET_X: 45,    // px from left
      DINO_HITBOX_OFFSET_Y: 35,     // px from top
      DINO_HITBOX_WIDTH: 30,       // px
      DINO_HITBOX_HEIGHT: 50,      // px

      // Image sets (chosen once per run)
      DINO_PREFIX: "sloth",     DINO_IDS: ["01"],     // sloth01_a.png / sloth01_b.png ...
      OBST_PREFIX: "prop",      OBST_IDS: ["01"],     // ground:  prop01.png ...
      AOBST_PREFIX: "propair",  AOBST_IDS: ["01","02","03"],    // air:     propair01.png ...

      // Image scale multipliers (applied to actual image size)
      DINO_IMAGE_SCALE: 1.0,     // 1.0 = 100%, 0.5 = 50%, 2.0 = 200%, etc.
      OBST_IMAGE_SCALE: 1.0,
      AOBST_IMAGE_SCALE: 1.0,

      // Fallbacks (when images missing)
      DINO_FALLBACK_COLOR: "#000000",
      OBST_FALLBACK_COLOR: "#e53935",

      // Feature toggles
      ENABLE_AIR_OBSTACLES: false,      // Enable/disable air obstacles
      ENABLE_SCROLL_BACKGROUND: false,  // Enable/disable parallax background layers
      SHOW_HITBOX: false,               // Show hitbox visualization (green semi-transparent box)

      // ===== 4-Layer Parallax Background =====
      // Layer 1: Far Background (ÏõêÍ≤Ω - Í∞ÄÏû• ÎäêÎ¶º)
      LAYER_FAR_PREFIX: "bgfar",
      LAYER_FAR_IDS: ["01","02","03"],
      LAYER_FAR_SCROLL_PARALLAX: 0.2,     // slowest
      LAYER_FAR_DRAW_WIDTH: 400,
      LAYER_FAR_DRAW_HEIGHT: 180,
      LAYER_FAR_Y: 40,
      LAYER_FAR_FALLBACK_ALPHA: 0.3,

      // Layer 2: Background (Î∞∞Í≤Ω)
      LAYER_BG_PREFIX: "bg",
      LAYER_BG_IDS: ["01","02","03"],
      LAYER_BG_SCROLL_PARALLAX: 0.4,
      LAYER_BG_DRAW_WIDTH: 400,
      LAYER_BG_DRAW_HEIGHT: 180,
      LAYER_BG_Y: 40,
      LAYER_BG_FALLBACK_ALPHA: 0.5,

      // Layer 3: Midground (Ï§ëÍ≤Ω)
      LAYER_MID_PREFIX: "bgmid",
      LAYER_MID_IDS: ["01","02","03"],
      LAYER_MID_SCROLL_PARALLAX: 0.6,
      LAYER_MID_DRAW_WIDTH: 400,
      LAYER_MID_DRAW_HEIGHT: 180,
      LAYER_MID_Y: 40,
      LAYER_MID_FALLBACK_ALPHA: 0.7,

      // Layer 4: Foreground (Ï†ÑÍ≤Ω - Í∞ÄÏû• Îπ†Î¶Ñ)
      LAYER_FORE_PREFIX: "bgfore",
      LAYER_FORE_IDS: ["01","02","03"],
      LAYER_FORE_SCROLL_PARALLAX: 0.8,    // fastest
      LAYER_FORE_DRAW_WIDTH: 400,
      LAYER_FORE_DRAW_HEIGHT: 180,
      LAYER_FORE_Y: 40,
      LAYER_FORE_FALLBACK_ALPHA: 0.9,

      // Shared fallback settings for all layers
      LAYER_FALLBACK_COLOR: "#ffd54f",    // yellow
      LAYER_FALLBACK_SIZE: 80,

      // Score
      SCORE_PER_OBSTACLE: 10,
      HIGH_SCORE_KEY: "dino_highscore_touch_v1",

      // Score display settings
      SCORE_FONT_SIZE: 20,        // px (score font size)
      HIGHSCORE_FONT_SIZE: 16,    // px (high score font size)
      SCORE_Y_POSITION: 50,       // px from top
      HIGHSCORE_Y_POSITION: 45,   // px from top
      SCORE_COLOR: "#000000",     // Score text color (default: black)
      HIGHSCORE_COLOR: "#000000", // High score text color (default: black)
      SCORE_ALPHA: 0.6,           // Score text alpha (0.0-1.0, default: 1.0)
      HIGHSCORE_ALPHA: 0.5,       // High score text alpha (0.0-1.0, default: 1.0)
      GROUND_LINE_COLOR: "#000000", // Ground line color (default: black)

      // ===== Scroll speed curve (affects obstacles & background) =====
      SPEED_BASE: 336,        // 280 px/s (base)
      SPEED_MAX_MULT: 3.5,    // 3 max multiplier (final speed = base * this)
      SPEED_RAMP_SECONDS: 30, // 60 seconds to reach max multiplier (linear)

      // ===== Obstacle spawn =====
      OBST_WIDTH: 30,
      OBST_HEIGHT: 50,
      OBST_BASE_GAP: 480,              // Base distance (px) for obstacle spacing
      OBST_GAP_MULTIPLIER_MIN: 1.0,    // Min gap multiplier
      OBST_GAP_MULTIPLIER_MAX: 2.0,   //1.64 Max gap multiplier (365 * 1.64 ‚âà 600)

      // Obstacle size multipliers (min/max for random variation)
      OBST_SIZE_MULTIPLIER_MIN: 0.8,//0.8
      OBST_SIZE_MULTIPLIER_MAX: 1.1, //1.1
      AOBST_SIZE_MULTIPLIER_MIN: 1.0,
      AOBST_SIZE_MULTIPLIER_MAX: 1.0,

      // Air obstacle (mutually exclusive with ground; probability based)
      AIR_OBST_PROB: 35,      // 0~100 (% chance to spawn air obstacle instead)
      AIR_OBST_Y: 160,        // top Y of the air obstacle (fixed height line)

      // ===== Variable jump (hold) =====
      JUMP_MIN_HEIGHT: 100,    // px
      JUMP_MAX_HEIGHT: 250,   // px
      JUMP_MIN_HOLD: 0.05,    // s  (<= -> min height)
      JUMP_MAX_HOLD: 0.25,    // s  (>= -> max height)
      GRAVITY: 4500,          // px/s^2

      // ===== Restart button size =====
      RESTART_BTN_WIDTH: 140, // px
      RESTART_BTN_HEIGHT: 48, // px
      RESTART_BTN_OFFSET_Y: 20, // px from bottom of game area (outside)

      // ===== Lyrics spawn system =====
      ENABLE_LYRICS: false,        // Enable/disable scrolling lyrics feature
      LYRICS_TEXT: "üéÇ Happy birth day to you     Happy birth day to you      Happy birth day dear Beam sloth      Happy birth day to you      ",
      LYRICS_FONT_SIZE: 60,
      LYRICS_FONT_BOLD: true,  // Set to true for bold lyrics
      LYRICS_SPACE_MULTIPLIER: 1,
      LYRICS_Y: 615,  // Y position for spawned lyrics (above game area)
      LYRICS_REPEAT_DELAY: 1.0,  // seconds delay before lyrics repeat
      LYRICS_COLOR: "#000000",    // Lyrics text color (default: black)
      LYRICS_ALPHA: 0.7,          // Lyrics text alpha (0.0-1.0, default: 1.0)

      // ===== Sequential lyrics (displayed on score) =====
      ENABLE_SEQUENTIAL_LYRICS: false,      // Enable/disable sequential lyrics feature
      SEQUENTIAL_LYRICS_TEXT: "üéÇ Happy birth day to you Happy birth day to you Happy birth day dear Beam Sloth Happy birth day to you",          // Sequential lyrics text (words separated by spaces)
      SEQUENTIAL_LYRICS_Y: 700,            // Y position for sequential lyrics (center of screen)
      SEQUENTIAL_LYRICS_FONT_SIZE: 120,     // Font size for sequential lyrics
      SEQUENTIAL_LYRICS_FONT_BOLD: true,   // Set to true for bold sequential lyrics
      SEQUENTIAL_LYRICS_COLOR: "#000000",  // Sequential lyrics text color
      SEQUENTIAL_LYRICS_ALPHA: 0.7,        // Sequential lyrics text alpha (0.0-1.0, default: 1.0)
      SEQUENTIAL_LYRICS_SHOW_DURATION: 0.3,  // Duration to show word before fading (seconds)
      SEQUENTIAL_LYRICS_FADE_DURATION: 0.2,   // Duration of fade out animation (seconds)
      ENABLE_SEQUENTIAL_LYRICS_PUNCH_EFFECT: false,  // Enable/disable punch effect (scale animation) for sequential lyrics

      // ===== Finish message (displayed on character when game ends) =====
      FINISH_MESSAGE: "I'm full",
      FINISH_MESSAGE_OFFSET_Y: -40, // px offset from character top (negative = above)
      FINISH_MESSAGE_FONT_SIZE: 28,
      FINISH_MESSAGE_COLOR: "#ff6b35",

      // ===== Particle effects =====
      // Jump particles (spawn when jumping from ground)
      ENABLE_JUMP_PARTICLES: false,           // Enable/disable jump particles
      JUMP_PARTICLE_COUNT: 8,                // Number of particles per jump
      JUMP_PARTICLE_COLOR: "#000000",        // Particle color (black)
      JUMP_PARTICLE_SIZE_MIN: 2,             // Min particle size (px)
      JUMP_PARTICLE_SIZE_MAX: 4,             // Max particle size (px)
      JUMP_PARTICLE_SPEED_MIN: 80,           // Min upward speed (px/s)
      JUMP_PARTICLE_SPEED_MAX: 180,          // Max upward speed (px/s)
      JUMP_PARTICLE_SPREAD: 40,              // Horizontal spread from jump point (px)
      JUMP_PARTICLE_LIFETIME: 0.2,           // Particle lifetime (seconds)
      JUMP_PARTICLE_GRAVITY: 500,            // Particle gravity (px/s^2)

      // Landing particles (spawn when landing on ground)
      ENABLE_LANDING_PARTICLES: false,        // Enable/disable landing particles
      LANDING_PARTICLE_COUNT: 10,            // Number of particles per landing
      LANDING_PARTICLE_COLOR: "#333333",     // Particle color (dark gray)
      LANDING_PARTICLE_SIZE_MIN: 2,          // Min particle size (px)
      LANDING_PARTICLE_SIZE_MAX: 5,          // Max particle size (px)
      LANDING_PARTICLE_SPEED_MIN: 100,       // Min upward speed (px/s)
      LANDING_PARTICLE_SPEED_MAX: 220,       // Max upward speed (px/s)
      LANDING_PARTICLE_SPREAD: 50,           // Horizontal spread from landing point (px)
      LANDING_PARTICLE_LIFETIME: 0.1,        // Particle lifetime (seconds)
      LANDING_PARTICLE_GRAVITY: 600,         // Particle gravity (px/s^2)

      // ===== Ground scroll dots =====
      ENABLE_GROUND_DOTS: true,              // Enable/disable ground scroll dots
      GROUND_DOT_SIZE: 3,                    // Dot size (px)
      GROUND_DOT_COLOR: "#000000",           // Dot color
      GROUND_DOT_ALPHA: 0.3,                 // Dot alpha (0.0-1.0)
      GROUND_DOT_Y_OFFSET: 20,               // Distance below ground line (px)
      GROUND_DOT_SPACING: 60                 // Horizontal spacing between dots (px)
    };

    // ===============================
    // Canvas & UI
    // ===============================
    const cvs = document.getElementById("game");
    const ctx = cvs.getContext("2d");
    const scoreEl = document.getElementById("score");
    const highScoreEl = document.getElementById("highScore");
    const overlay = document.getElementById("overlay");
    const restartBtn = document.getElementById("restartBtn");
    cvs.width = CONFIG.GAME_WIDTH; cvs.height = CONFIG.GAME_HEIGHT;

    // ===============================
    // Helpers
    // ===============================
    // Convert hex color to rgba with alpha value
    function hexToRgba(hex, alpha){
      // Remove # if present
      hex = hex.replace(/^#/, '');

      // Parse hex values
      let r, g, b;
      if(hex.length === 3){
        r = parseInt(hex[0] + hex[0], 16);
        g = parseInt(hex[1] + hex[1], 16);
        b = parseInt(hex[2] + hex[2], 16);
      }else if(hex.length === 6){
        r = parseInt(hex.substr(0, 2), 16);
        g = parseInt(hex.substr(2, 2), 16);
        b = parseInt(hex.substr(4, 2), 16);
      }else{
        // Invalid hex, return black with alpha
        return `rgba(0, 0, 0, ${alpha})`;
      }

      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    // Apply restart button size and position from CONFIG
    restartBtn.style.width = CONFIG.RESTART_BTN_WIDTH + "px";
    restartBtn.style.height = CONFIG.RESTART_BTN_HEIGHT + "px";
    restartBtn.style.bottom = CONFIG.RESTART_BTN_OFFSET_Y + "px";

    // Apply score display settings from CONFIG
    highScoreEl.style.fontSize = CONFIG.HIGHSCORE_FONT_SIZE + "px";
    highScoreEl.style.marginTop = CONFIG.HIGHSCORE_Y_POSITION + "px";
    highScoreEl.style.color = hexToRgba(CONFIG.HIGHSCORE_COLOR, CONFIG.HIGHSCORE_ALPHA);
    scoreEl.style.fontSize = CONFIG.SCORE_FONT_SIZE + "px";
    scoreEl.style.marginTop = (CONFIG.SCORE_Y_POSITION - CONFIG.HIGHSCORE_Y_POSITION) + "px";
    scoreEl.style.color = hexToRgba(CONFIG.SCORE_COLOR, CONFIG.SCORE_ALPHA);

    const imageCache = new Map();
    function loadImageOnce(src){
      if(imageCache.has(src)) return imageCache.get(src);
      const e = { img:new Image(), ok:false, loaded:false, width:0, height:0, pixelData:null };
      e.img.onload = ()=>{
        e.ok=true;
        e.loaded=true;
        e.width = e.img.naturalWidth;
        e.height = e.img.naturalHeight;
        // Extract pixel data for alpha-based collision detection
        extractPixelData(e);
      };
      e.img.onerror = ()=>{ e.ok=false; e.loaded=true; };
      e.img.src = src;
      imageCache.set(src, e);
      return e;
    }

    // Extract pixel data from loaded image for alpha-based collision
    function extractPixelData(entry){
      if(!entry.ok || !entry.img) return;
      try{
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = entry.width;
        tempCanvas.height = entry.height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(entry.img, 0, 0);
        entry.pixelData = tempCtx.getImageData(0, 0, entry.width, entry.height);
      }catch(err){
        // CORS or other issues - fallback to rect collision
        console.warn('Could not extract pixel data:', err);
      }
    }

    // Check if a pixel has non-transparent alpha (>128 = opaque enough)
    function isPixelOpaque(imageData, x, y){
      if(!imageData || x<0 || y<0 || x>=imageData.width || y>=imageData.height) return false;
      const idx = (Math.floor(y) * imageData.width + Math.floor(x)) * 4;
      return imageData.data[idx + 3] > 128; // alpha channel
    }

    // Alpha-based collision detection between rectangle and image
    // rectX, rectY, rectW, rectH: rectangle hitbox (character)
    // imgX, imgY, imgW, imgH: image position and size (obstacle)
    // imgEntry: image entry with pixel data (obstacle)
    function rectAlphaCollision(rectX, rectY, rectW, rectH, imgX, imgY, imgW, imgH, imgEntry){
      // Calculate overlap rectangle
      const overlapX = Math.max(rectX, imgX);
      const overlapY = Math.max(rectY, imgY);
      const overlapRight = Math.min(rectX + rectW, imgX + imgW);
      const overlapBottom = Math.min(rectY + rectH, imgY + imgH);
      const overlapW = overlapRight - overlapX;
      const overlapH = overlapBottom - overlapY;

      if(overlapW <= 0 || overlapH <= 0) return false;

      // If no pixel data available, fall back to rectangle collision
      if(!imgEntry || !imgEntry.pixelData) return true;

      // Sample pixels in the overlap region (check every few pixels for performance)
      const step = 3; // Check every 3 pixels
      for(let dy = 0; dy < overlapH; dy += step){
        for(let dx = 0; dx < overlapW; dx += step){
          const worldX = overlapX + dx;
          const worldY = overlapY + dy;

          // Map to image coordinates
          const imgPixelX = ((worldX - imgX) / imgW) * imgEntry.width;
          const imgPixelY = ((worldY - imgY) / imgH) * imgEntry.height;

          // Check if pixel is opaque in the obstacle image
          if(isPixelOpaque(imgEntry.pixelData, imgPixelX, imgPixelY)){
            return true; // Collision detected!
          }
        }
      }

      return false; // No opaque pixel overlap
    }

    const pick = arr => arr[(Math.random()*arr.length)|0];
    const randInt = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;
    const randFloat = (a,b)=>Math.random()*(b-a)+a;
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const rectsOverlap=(ax,ay,aw,ah,bx,by,bw,bh)=>ax<bx+bw&&ax+aw>bx&&ay<by+bh&&ay+ah>by;

    // ===============================
    // Per-run selections (fixed during a run)
    // ===============================
    let curDinoId=null, curGroundId=null, curAirId=null;
    let curLayerFarId=null, curLayerBgId=null, curLayerMidId=null, curLayerForeId=null;
    function chooseRunAssets(){
      curDinoId     = pick(CONFIG.DINO_IDS);
      curGroundId   = pick(CONFIG.OBST_IDS);
      curAirId      = pick(CONFIG.AOBST_IDS);
      curLayerFarId = pick(CONFIG.LAYER_FAR_IDS);
      curLayerBgId  = pick(CONFIG.LAYER_BG_IDS);
      curLayerMidId = pick(CONFIG.LAYER_MID_IDS);
      curLayerForeId= pick(CONFIG.LAYER_FORE_IDS);
      // Preload (fallbacks if missing)
      loadImageOnce(`${CONFIG.DINO_PREFIX}${curDinoId}_a.png`);
      loadImageOnce(`${CONFIG.DINO_PREFIX}${curDinoId}_b.png`);
      loadImageOnce(`${CONFIG.OBST_PREFIX}${curGroundId}.png`);
      loadImageOnce(`${CONFIG.AOBST_PREFIX}${curAirId}.png`);
      loadImageOnce(`${CONFIG.LAYER_FAR_PREFIX}${curLayerFarId}.png`);
      loadImageOnce(`${CONFIG.LAYER_BG_PREFIX}${curLayerBgId}.png`);
      loadImageOnce(`${CONFIG.LAYER_MID_PREFIX}${curLayerMidId}.png`);
      loadImageOnce(`${CONFIG.LAYER_FORE_PREFIX}${curLayerForeId}.png`);
    }

    // ===============================
    // Game state
    // ===============================
    const state = {
      running:false, dead:false,
      runStartTime:0, lastTime:0, animTime:0,
      score:0, highScore:Number(localStorage.getItem(CONFIG.HIGH_SCORE_KEY)||0),
      distSinceLast:0
    };

    const dino = {
      x:CONFIG.DINO_X, y:CONFIG.GROUND_Y-CONFIG.DINO_HEIGHT, w:CONFIG.DINO_WIDTH, h:CONFIG.DINO_HEIGHT,
      vy:0, onGround:true,
      holding:false, holdElapsed:0
    };

    // Obstacles / parallax layers
    let obstacles=[]; // {x,y,w,h,scored?:bool, air?:bool}
    let layerFarTiles=[], layerBgTiles=[], layerMidTiles=[], layerForeTiles=[]; // {x,y,w,h}
    let layerFarAdjusted=false, layerBgAdjusted=false, layerMidAdjusted=false, layerForeAdjusted=false;
    let randGap=0;

    // Particles
    let particles=[]; // {x, y, vx, vy, size, color, lifetime, age, gravity}

    // Ground scroll dots
    let groundDots=[]; // {x, y}

    // Lyrics spawn system
    let letters=[]; // {char, x, y, w, speed}
    let lyricsIndex=0, elapsedTime=0, nextSpawnTime=0, baseInterval=0;
    let lyricsRepeatDelayRemaining=0; // remaining delay before lyrics repeat

    // Sequential lyrics system
    let sequentialLyricsWords=[]; // Array of words split by spaces
    let sequentialLyricsIndex=0; // Current word index
    let currentSequentialWord=null; // {word, spawnTime, scale} - currently displayed word

    // Variable jump precompute
    const v0_min = Math.sqrt(2*CONFIG.GRAVITY*CONFIG.JUMP_MIN_HEIGHT);
    const v0_max = Math.sqrt(2*CONFIG.GRAVITY*CONFIG.JUMP_MAX_HEIGHT);
    const v0_add_total = Math.max(0, v0_max - v0_min);
    const hold_window = Math.max(0.0001, CONFIG.JUMP_MAX_HOLD - CONFIG.JUMP_MIN_HOLD);

    // ===============================
    // Particle system
    // ===============================
    function createJumpParticles(){
      if(!CONFIG.ENABLE_JUMP_PARTICLES) return;

      const x = dino.x + CONFIG.DINO_HITBOX_OFFSET_X + CONFIG.DINO_HITBOX_WIDTH / 2;
      const y = CONFIG.GROUND_Y;

      for(let i = 0; i < CONFIG.JUMP_PARTICLE_COUNT; i++){
        particles.push({
          x: x + randFloat(-CONFIG.JUMP_PARTICLE_SPREAD / 2, CONFIG.JUMP_PARTICLE_SPREAD / 2),
          y: y,
          vx: randFloat(-50, 50), // slight horizontal variation
          vy: -randFloat(CONFIG.JUMP_PARTICLE_SPEED_MIN, CONFIG.JUMP_PARTICLE_SPEED_MAX),
          size: randFloat(CONFIG.JUMP_PARTICLE_SIZE_MIN, CONFIG.JUMP_PARTICLE_SIZE_MAX),
          color: CONFIG.JUMP_PARTICLE_COLOR,
          lifetime: CONFIG.JUMP_PARTICLE_LIFETIME,
          age: 0,
          gravity: CONFIG.JUMP_PARTICLE_GRAVITY
        });
      }
    }

    function createLandingParticles(){
      if(!CONFIG.ENABLE_LANDING_PARTICLES) return;

      const x = dino.x + CONFIG.DINO_HITBOX_OFFSET_X + CONFIG.DINO_HITBOX_WIDTH / 2;
      const y = CONFIG.GROUND_Y;

      for(let i = 0; i < CONFIG.LANDING_PARTICLE_COUNT; i++){
        particles.push({
          x: x + randFloat(-CONFIG.LANDING_PARTICLE_SPREAD / 2, CONFIG.LANDING_PARTICLE_SPREAD / 2),
          y: y,
          vx: randFloat(-80, 80), // more horizontal variation on landing
          vy: -randFloat(CONFIG.LANDING_PARTICLE_SPEED_MIN, CONFIG.LANDING_PARTICLE_SPEED_MAX),
          size: randFloat(CONFIG.LANDING_PARTICLE_SIZE_MIN, CONFIG.LANDING_PARTICLE_SIZE_MAX),
          color: CONFIG.LANDING_PARTICLE_COLOR,
          lifetime: CONFIG.LANDING_PARTICLE_LIFETIME,
          age: 0,
          gravity: CONFIG.LANDING_PARTICLE_GRAVITY
        });
      }
    }

    function updateParticles(dt){
      for(let i = particles.length - 1; i >= 0; i--){
        const p = particles[i];
        p.age += dt;

        // Remove dead particles
        if(p.age >= p.lifetime){
          particles.splice(i, 1);
          continue;
        }

        // Update position
        p.vy += p.gravity * dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
      }
    }

    function renderParticles(){
      for(const p of particles){
        // Fade out based on age
        const alpha = 1.0 - (p.age / p.lifetime);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
      }
      ctx.globalAlpha = 1.0; // reset
    }

    // ===============================
    // Ground scroll dots system
    // ===============================
    function initGroundDots(){
      if(!CONFIG.ENABLE_GROUND_DOTS) return;
      groundDots.length = 0;

      const dotY = CONFIG.GROUND_Y + CONFIG.GROUND_DOT_Y_OFFSET;
      const dotsNeeded = Math.ceil(CONFIG.GAME_WIDTH / CONFIG.GROUND_DOT_SPACING) + 1;

      for(let i = 0; i < dotsNeeded; i++){
        groundDots.push({
          x: i * CONFIG.GROUND_DOT_SPACING,
          y: dotY
        });
      }
    }

    function updateGroundDots(dt, speed){
      if(!CONFIG.ENABLE_GROUND_DOTS) return;

      const dotY = CONFIG.GROUND_Y + CONFIG.GROUND_DOT_Y_OFFSET;

      // Move all dots left
      for(const dot of groundDots){
        dot.x -= speed * dt;
      }

      // Remove dots that moved off-screen (left side)
      while(groundDots.length > 0 && groundDots[0].x < -CONFIG.GROUND_DOT_SPACING){
        groundDots.shift();
      }

      // Add new dots on the right side as needed
      while(groundDots.length === 0 || groundDots[groundDots.length - 1].x < CONFIG.GAME_WIDTH){
        const lastX = groundDots.length > 0 ? groundDots[groundDots.length - 1].x : -CONFIG.GROUND_DOT_SPACING;
        groundDots.push({
          x: lastX + CONFIG.GROUND_DOT_SPACING,
          y: dotY
        });
      }
    }

    function renderGroundDots(){
      if(!CONFIG.ENABLE_GROUND_DOTS) return;

      ctx.globalAlpha = CONFIG.GROUND_DOT_ALPHA;
      ctx.fillStyle = CONFIG.GROUND_DOT_COLOR;

      for(const dot of groundDots){
        ctx.beginPath();
        ctx.arc(dot.x, dot.y, CONFIG.GROUND_DOT_SIZE / 2, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.globalAlpha = 1.0; // reset
    }

    // ===============================
    // Speed curve (base * linear ramp)
    // ===============================
    function currentScrollSpeed(nowMs){
      const t = Math.max(0, (nowMs - state.runStartTime)/1000);
      const r = CONFIG.SPEED_RAMP_SECONDS>0 ? clamp(t/CONFIG.SPEED_RAMP_SECONDS,0,1) : 1;
      const mult = 1 + (CONFIG.SPEED_MAX_MULT - 1) * r;
      return CONFIG.SPEED_BASE * mult;
    }

    // ===============================
    // Reset / Game Over
    // ===============================
    function resetGame(){
      state.running = true; state.dead=false;
      state.runStartTime = performance.now();
      state.lastTime = state.runStartTime;
      state.animTime = 0; state.score=0; state.distSinceLast=0;

      dino.x=CONFIG.DINO_X; dino.y=CONFIG.GROUND_Y-dino.h;
      dino.vy=0; dino.onGround=true; dino.holding=false; dino.holdElapsed=0;

      chooseRunAssets();

      obstacles.length=0;
      particles.length=0;
      groundDots.length=0;
      layerFarTiles.length=0; layerBgTiles.length=0;
      layerMidTiles.length=0; layerForeTiles.length=0;
      layerFarAdjusted=false; layerBgAdjusted=false;
      layerMidAdjusted=false; layerForeAdjusted=false;
      // Initialize gap with average multipliers
      const avgGapMult = (CONFIG.OBST_GAP_MULTIPLIER_MIN + CONFIG.OBST_GAP_MULTIPLIER_MAX) / 2;
      const avgSizeMult = (CONFIG.OBST_SIZE_MULTIPLIER_MIN + CONFIG.OBST_SIZE_MULTIPLIER_MAX) / 2;
      randGap = CONFIG.OBST_BASE_GAP * avgGapMult * avgSizeMult;

      // Lyrics system initialization
      letters.length = 0;
      lyricsIndex = 0;
      elapsedTime = 0;
      nextSpawnTime = 0;
      lyricsRepeatDelayRemaining = 0;
      baseInterval = CONFIG.LYRICS_FONT_SIZE / CONFIG.SPEED_BASE;

      // Sequential lyrics system initialization
      sequentialLyricsWords = CONFIG.SEQUENTIAL_LYRICS_TEXT
        .split(' ')
        .filter(word => word.length > 0); // Split by spaces and remove empty strings
      sequentialLyricsIndex = 0;
      currentSequentialWord = null;

      // Initialize 4 parallax layers (3 tiles each for seamless scrolling)
      initLayerTiles(layerFarTiles, CONFIG.LAYER_FAR_DRAW_WIDTH, CONFIG.LAYER_FAR_DRAW_HEIGHT, CONFIG.LAYER_FAR_Y);
      initLayerTiles(layerBgTiles, CONFIG.LAYER_BG_DRAW_WIDTH, CONFIG.LAYER_BG_DRAW_HEIGHT, CONFIG.LAYER_BG_Y);
      initLayerTiles(layerMidTiles, CONFIG.LAYER_MID_DRAW_WIDTH, CONFIG.LAYER_MID_DRAW_HEIGHT, CONFIG.LAYER_MID_Y);
      initLayerTiles(layerForeTiles, CONFIG.LAYER_FORE_DRAW_WIDTH, CONFIG.LAYER_FORE_DRAW_HEIGHT, CONFIG.LAYER_FORE_Y);

      // Initialize ground scroll dots
      initGroundDots();

      overlay.style.display="none";
      scoreEl.textContent = `SCORE: ${state.score}`;
      highScoreEl.textContent = `HIGH SCORE: ${state.highScore}`;
      requestAnimationFrame(loop);
    }

    function gameOver(){
      state.dead=true; state.running=false;
      if(state.score > state.highScore){
        state.highScore = state.score;
        localStorage.setItem(CONFIG.HIGH_SCORE_KEY, String(state.highScore));
      }
      highScoreEl.textContent = `HIGH SCORE: ${state.highScore}`;
      overlay.style.display = "grid";
    }

    // ===============================
    // Layer initialization & scrolling helpers
    // ===============================
    function initLayerTiles(tilesArray, width, height, y){
      tilesArray.push({x:0, y, w:width, h:height});
      tilesArray.push({x:width, y, w:width, h:height});
      tilesArray.push({x:width*2, y, w:width, h:height});
    }

    // Adjust tiles based on actual image size (called once image loads)
    function adjustLayerForImage(tilesArray, imgWidth, imgHeight, targetHeight){
      if(tilesArray.length===0 || !imgWidth || !imgHeight) return;

      // Calculate scaled width maintaining aspect ratio
      const aspectRatio = imgWidth / imgHeight;
      const scaledWidth = targetHeight * aspectRatio;

      // Calculate how many tiles needed to cover screen + buffer
      const tilesNeeded = Math.ceil(CONFIG.GAME_WIDTH / scaledWidth) + 2;

      // Update existing tiles and add more if needed
      const y = tilesArray[0].y;
      tilesArray.length = 0;
      for(let i = 0; i < tilesNeeded; i++){
        tilesArray.push({x: i * scaledWidth, y, w: scaledWidth, h: targetHeight});
      }
    }

    function updateLayerScroll(tilesArray, scrollDelta){
      if(tilesArray.length===0) return;
      const tileW = tilesArray[0].w;
      let maxX = -Infinity;

      // Move all tiles left
      for(const t of tilesArray){
        t.x -= scrollDelta;
        if(t.x > maxX) maxX = t.x;
      }

      // Wrap tiles that moved off-screen to the right
      for(const t of tilesArray){
        if(t.x + tileW < 0){
          t.x = maxX + tileW;
          maxX = t.x;
        }
      }
    }

    // ===============================
    // Spawning
    // ===============================
    function trySpawnObstacle(speed){
      if(state.distSinceLast < randGap) return;

      // If air obstacles disabled, only spawn ground obstacles
      const useAir = CONFIG.ENABLE_AIR_OBSTACLES && (randInt(1,100) <= CONFIG.AIR_OBST_PROB);
      const key = useAir
        ? `${CONFIG.AOBST_PREFIX}${curAirId}.png`
        : `${CONFIG.OBST_PREFIX}${curGroundId}.png`;

      const e = imageCache.get(key) || loadImageOnce(key);

      // Calculate size multiplier (random between min and max)
      const minMult = useAir ? CONFIG.AOBST_SIZE_MULTIPLIER_MIN : CONFIG.OBST_SIZE_MULTIPLIER_MIN;
      const maxMult = useAir ? CONFIG.AOBST_SIZE_MULTIPLIER_MAX : CONFIG.OBST_SIZE_MULTIPLIER_MAX;
      const sizeMult = (minMult === maxMult) ? minMult : randFloat(minMult, maxMult);

      // Use original image size * scale * size multiplier if loaded, otherwise use fallback size
      let w, h;
      if(e.loaded && e.ok && e.width > 0 && e.height > 0){
        const scale = useAir ? CONFIG.AOBST_IMAGE_SCALE : CONFIG.OBST_IMAGE_SCALE;
        w = e.width * scale * sizeMult;
        h = e.height * scale * sizeMult;
      }else{
        w = CONFIG.OBST_WIDTH * sizeMult;
        h = CONFIG.OBST_HEIGHT * sizeMult;
      }

      if(useAir){
        obstacles.push({ x: CONFIG.GAME_WIDTH + w, y: CONFIG.AIR_OBST_Y, w, h, scored:false, air:true });
      }else{
        obstacles.push({ x: CONFIG.GAME_WIDTH + w, y: CONFIG.GROUND_Y - h, w, h, scored:false, air:false });
      }

      state.distSinceLast = 0;
      // Calculate next gap: base_gap * gap_multiplier(random) * size_multiplier(current obstacle)
      const gapMult = randFloat(CONFIG.OBST_GAP_MULTIPLIER_MIN, CONFIG.OBST_GAP_MULTIPLIER_MAX);
      randGap = CONFIG.OBST_BASE_GAP * gapMult * sizeMult;
    }

    // ===============================
    // Input ‚Äî whole page touch/press for jump
    // ===============================
    let pressActive=false;
    function onPressStart(ev){
      if(state.dead) return;                 // ignore when game over screen
      if(!state.running) return;
      if(dino.onGround && !pressActive){
        pressActive=true; dino.holding=true; dino.holdElapsed=0;
        dino.vy = -v0_min;                   // initial minimal jump impulse
        dino.onGround=false;
        createJumpParticles();               // spawn jump particles
      }
    }
    function onPressEnd(ev){
      pressActive=false;
      dino.holding=false;
    }

    // Page-wide pointer listeners (anywhere -> jump)
    window.addEventListener("pointerdown", onPressStart, {passive:false});
    window.addEventListener("pointerup", onPressEnd, {passive:false});

    // Also allow Space/ArrowUp on desktop (optional)
    window.addEventListener("keydown", e=>{
      if(e.code==="Space"||e.code==="ArrowUp"){ e.preventDefault(); onPressStart(); }
    }, {passive:false});
    window.addEventListener("keyup", e=>{
      if(e.code==="Space"||e.code==="ArrowUp"){ e.preventDefault(); onPressEnd(); }
    }, {passive:false});

    // Restart
    document.getElementById("restartBtn").addEventListener("click", resetGame);

    // ===============================
    // Main loop
    // ===============================
    function loop(now){
      if(!state.running) return;
      const dt = Math.min(0.032, (now - state.lastTime)/1000);
      state.lastTime = now;
      state.animTime += dt;

      const speed = currentScrollSpeed(now);
      state.distSinceLast += speed * dt;

      // Variable jump hold ‚Äî add extra upward velocity while holding
      if(dino.holding && !dino.onGround){
        dino.holdElapsed += dt;
        if(dino.holdElapsed > CONFIG.JUMP_MIN_HOLD){
          const over = Math.min(dino.holdElapsed, CONFIG.JUMP_MAX_HOLD) - CONFIG.JUMP_MIN_HOLD;
          const addRate = (hold_window>0) ? (v0_add_total / hold_window) : 0;
          const dv = addRate * dt;
          dino.vy -= dv; // upward extra impulse (vy negative is up)
          if(dino.holdElapsed >= CONFIG.JUMP_MAX_HOLD) dino.holding=false;
        }
      }

      // Gravity
      dino.vy += CONFIG.GRAVITY * dt;
      dino.y  += dino.vy * dt;

      // Ground collision
      const groundTop = CONFIG.GROUND_Y - dino.h;
      if(dino.y >= groundTop){
        const wasInAir = !dino.onGround; // track if we were in air before landing
        dino.y = groundTop; dino.vy = 0; dino.onGround = true; dino.holding = false;
        if(wasInAir){
          createLandingParticles(); // spawn landing particles
        }
      }

      // Spawns
      trySpawnObstacle(speed);

      // Lyrics spawn system (only if enabled)
      if(CONFIG.ENABLE_LYRICS){
        elapsedTime += dt;

        // Handle lyrics repeat delay
        if(lyricsIndex >= CONFIG.LYRICS_TEXT.length){
          if(lyricsRepeatDelayRemaining > 0){
            lyricsRepeatDelayRemaining -= dt;
          }else{
            // Reset lyrics to repeat
            lyricsIndex = 0;
            nextSpawnTime = elapsedTime;
            lyricsRepeatDelayRemaining = CONFIG.LYRICS_REPEAT_DELAY;
          }
        }

        // Spawn lyrics characters
        while(lyricsIndex < CONFIG.LYRICS_TEXT.length && elapsedTime >= nextSpawnTime){
          const ch = CONFIG.LYRICS_TEXT[lyricsIndex++];
          if(ch === " "){
            nextSpawnTime += baseInterval * CONFIG.LYRICS_SPACE_MULTIPLIER;
            continue;
          }
          letters.push({
            char: ch,
            x: CONFIG.GAME_WIDTH + CONFIG.LYRICS_FONT_SIZE,
            y: CONFIG.LYRICS_Y,
            w: CONFIG.LYRICS_FONT_SIZE,
            speed: speed
          });
          nextSpawnTime += baseInterval;
        }

        // Lyrics update
        for(let i = letters.length - 1; i >= 0; i--){
          const letter = letters[i];
          letter.x -= speed * dt;
          if(letter.x + letter.w < -10){
            letters.splice(i, 1);
          }
        }
      }

      // Obstacles update
      for(let i=obstacles.length-1;i>=0;i--){
        const ob = obstacles[i];
        ob.x -= speed * dt;

        if(!ob.scored && ob.x + ob.w < dino.x){
          ob.scored = true;
          state.score += CONFIG.SCORE_PER_OBSTACLE;
          scoreEl.textContent = `SCORE: ${state.score}`;

          // Trigger score popup animation
          scoreEl.classList.remove('score-popup');
          void scoreEl.offsetWidth; // Force reflow to restart animation
          scoreEl.classList.add('score-popup');

          // Sequential lyrics: display next word on score
          if(CONFIG.ENABLE_SEQUENTIAL_LYRICS && sequentialLyricsWords.length > 0){
            const word = sequentialLyricsWords[sequentialLyricsIndex];
            currentSequentialWord = {
              word: word,
              spawnTime: now / 1000, // Convert to seconds
              scale: 1.0
            };
            // Move to next word (loop back to start if at end)
            sequentialLyricsIndex = (sequentialLyricsIndex + 1) % sequentialLyricsWords.length;
          }
        }

        // Character hitbox (rectangle collision)
        const hitboxX = dino.x + CONFIG.DINO_HITBOX_OFFSET_X;
        const hitboxY = dino.y + CONFIG.DINO_HITBOX_OFFSET_Y;
        const hitboxW = CONFIG.DINO_HITBOX_WIDTH;
        const hitboxH = CONFIG.DINO_HITBOX_HEIGHT;

        // Check collision: character rectangle hitbox vs obstacle alpha pixels
        let collision = false;

        // Get obstacle image
        const isAir = !!ob.air;
        const obKey = isAir
          ? `${CONFIG.AOBST_PREFIX}${curAirId}.png`
          : `${CONFIG.OBST_PREFIX}${curGroundId}.png`;
        const obEntry = imageCache.get(obKey);

        // Use rectangle-alpha collision (character rect vs obstacle alpha pixels)
        collision = rectAlphaCollision(
          hitboxX, hitboxY, hitboxW, hitboxH,
          ob.x, ob.y, ob.w, ob.h, obEntry
        );

        if(collision){
          gameOver(); render(); return;
        }
        if(ob.x + ob.w < -50) obstacles.splice(i,1);
      }

      // Update 4 parallax layers (each with different scroll speed)
      updateLayerScroll(layerFarTiles, speed * CONFIG.LAYER_FAR_SCROLL_PARALLAX * dt);
      updateLayerScroll(layerBgTiles, speed * CONFIG.LAYER_BG_SCROLL_PARALLAX * dt);
      updateLayerScroll(layerMidTiles, speed * CONFIG.LAYER_MID_SCROLL_PARALLAX * dt);
      updateLayerScroll(layerForeTiles, speed * CONFIG.LAYER_FORE_SCROLL_PARALLAX * dt);

      // Update particles
      updateParticles(dt);

      // Update ground scroll dots
      updateGroundDots(dt, speed);

      render();
      requestAnimationFrame(loop);
    }

    // ===============================
    // Render
    // ===============================
    function render(){
      ctx.clearRect(0,0,CONFIG.GAME_WIDTH,CONFIG.GAME_HEIGHT);

      // 4 parallax layers (back to front) - only if enabled
      if(CONFIG.ENABLE_SCROLL_BACKGROUND){
        layerFarAdjusted = drawLayer(layerFarTiles, CONFIG.LAYER_FAR_PREFIX, curLayerFarId, CONFIG.LAYER_FAR_FALLBACK_ALPHA, CONFIG.LAYER_FAR_DRAW_HEIGHT, layerFarAdjusted);
        layerBgAdjusted = drawLayer(layerBgTiles, CONFIG.LAYER_BG_PREFIX, curLayerBgId, CONFIG.LAYER_BG_FALLBACK_ALPHA, CONFIG.LAYER_BG_DRAW_HEIGHT, layerBgAdjusted);
        layerMidAdjusted = drawLayer(layerMidTiles, CONFIG.LAYER_MID_PREFIX, curLayerMidId, CONFIG.LAYER_MID_FALLBACK_ALPHA, CONFIG.LAYER_MID_DRAW_HEIGHT, layerMidAdjusted);
        layerForeAdjusted = drawLayer(layerForeTiles, CONFIG.LAYER_FORE_PREFIX, curLayerForeId, CONFIG.LAYER_FORE_FALLBACK_ALPHA, CONFIG.LAYER_FORE_DRAW_HEIGHT, layerForeAdjusted);
      }

      // Ground line
      ctx.strokeStyle = CONFIG.GROUND_LINE_COLOR;
      ctx.lineWidth = CONFIG.GROUND_LINE_WIDTH;
      ctx.beginPath();
      ctx.moveTo(0, CONFIG.GROUND_Y+0.5);
      ctx.lineTo(CONFIG.GAME_WIDTH, CONFIG.GROUND_Y+0.5);
      ctx.stroke();

      // Ground scroll dots (drawn below ground line)
      renderGroundDots();

      // Particles (drawn behind player and obstacles)
      renderParticles();

      // Player
      drawDino();

      // Obstacles
      for(const ob of obstacles) drawObstacle(ob);

      // Hitbox visualization (if enabled)
      if(CONFIG.SHOW_HITBOX){
        // Draw character hitbox
        ctx.strokeStyle = "rgba(0, 255, 0, 0.7)";
        ctx.fillStyle = "rgba(0, 255, 0, 0.2)";
        ctx.lineWidth = 2;
        const hitboxX = dino.x + CONFIG.DINO_HITBOX_OFFSET_X;
        const hitboxY = dino.y + CONFIG.DINO_HITBOX_OFFSET_Y;
        ctx.fillRect(hitboxX, hitboxY, CONFIG.DINO_HITBOX_WIDTH, CONFIG.DINO_HITBOX_HEIGHT);
        ctx.strokeRect(hitboxX, hitboxY, CONFIG.DINO_HITBOX_WIDTH, CONFIG.DINO_HITBOX_HEIGHT);

        // Draw obstacle hitboxes
        ctx.strokeStyle = "rgba(255, 0, 0, 0.7)";
        ctx.fillStyle = "rgba(255, 0, 0, 0.2)";
        for(const ob of obstacles){
          ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
          ctx.strokeRect(ob.x, ob.y, ob.w, ob.h);
        }
      }

      // Lyrics (only if enabled)
      if(CONFIG.ENABLE_LYRICS){
        const lyricsFontWeight = CONFIG.LYRICS_FONT_BOLD ? "bold" : "normal";
        ctx.font = `${lyricsFontWeight} ${CONFIG.LYRICS_FONT_SIZE}px system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans", Arial, sans-serif`;
        ctx.fillStyle = hexToRgba(CONFIG.LYRICS_COLOR, CONFIG.LYRICS_ALPHA);
        for(const l of letters){
          ctx.fillText(l.char, l.x, l.y);
        }
      }

      // Sequential lyrics (centered word with punch effect and fade out)
      if(CONFIG.ENABLE_SEQUENTIAL_LYRICS && currentSequentialWord){
        const currentTime = state.lastTime / 1000; // Convert to seconds
        const elapsed = currentTime - currentSequentialWord.spawnTime;

        // Calculate punch effect (scale animation - same as score popup)
        let scale = 1.0;
        if(CONFIG.ENABLE_SEQUENTIAL_LYRICS_PUNCH_EFFECT){
          const punchDuration = 0.3; // 0.3 seconds punch animation
          if(elapsed < punchDuration){
            const t = elapsed / punchDuration;
            // Apply ease-out timing function: 1 - (1-t)^3
            const easeOut = 1 - Math.pow(1 - t, 3);
            // Scale from 1.0 to 1.2 at 50%, then back to 1.0 (same as score)
            if(easeOut < 0.5){
              scale = 1.0 + (0.2 * (easeOut / 0.5)); // 1.0 -> 1.2
            }else{
              scale = 1.2 - (0.2 * ((easeOut - 0.5) / 0.5)); // 1.2 -> 1.0
            }
          }
        }

        // Calculate fade out
        let alpha = 1.0;
        const totalLifetime = CONFIG.SEQUENTIAL_LYRICS_SHOW_DURATION + CONFIG.SEQUENTIAL_LYRICS_FADE_DURATION;
        if(elapsed > CONFIG.SEQUENTIAL_LYRICS_SHOW_DURATION){
          const fadeElapsed = elapsed - CONFIG.SEQUENTIAL_LYRICS_SHOW_DURATION;
          alpha = Math.max(0, 1.0 - (fadeElapsed / CONFIG.SEQUENTIAL_LYRICS_FADE_DURATION));
        }

        // Remove word if lifetime exceeded
        if(elapsed > totalLifetime){
          currentSequentialWord = null;
        }else{
          // Draw the word
          const seqLyricsFontWeight = CONFIG.SEQUENTIAL_LYRICS_FONT_BOLD ? "bold" : "normal";
          ctx.font = `${seqLyricsFontWeight} ${CONFIG.SEQUENTIAL_LYRICS_FONT_SIZE}px system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans", Arial, sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";

          // Apply alpha (multiply fade alpha with config alpha)
          ctx.globalAlpha = alpha * CONFIG.SEQUENTIAL_LYRICS_ALPHA;
          ctx.fillStyle = CONFIG.SEQUENTIAL_LYRICS_COLOR;

          // Apply scale transform
          ctx.save();
          ctx.translate(CONFIG.GAME_WIDTH / 2, CONFIG.SEQUENTIAL_LYRICS_Y);
          ctx.scale(scale, scale);
          ctx.fillText(currentSequentialWord.word, 0, 0);
          ctx.restore();

          // Reset context state
          ctx.globalAlpha = 1.0;
          ctx.textAlign = "left";
          ctx.textBaseline = "alphabetic";
        }
      }

      // Finish message (displayed on character when game ends)
      if(state.dead){
        // Get character image to calculate center
        const frame = Math.floor(state.animTime * 8) % 2;
        const key = `${CONFIG.DINO_PREFIX}${curDinoId}_${frame===0?"a":"b"}.png`;
        const e = imageCache.get(key);

        // Calculate character width (actual rendered width)
        let charWidth = dino.w; // fallback
        if(e && e.loaded && e.ok){
          charWidth = e.width * CONFIG.DINO_IMAGE_SCALE;
        }

        ctx.font = `bold ${CONFIG.FINISH_MESSAGE_FONT_SIZE}px Arial`;
        ctx.fillStyle = CONFIG.FINISH_MESSAGE_COLOR;
        ctx.textAlign = "center";
        ctx.textBaseline = "bottom";
        // Auto-center on character's x-axis
        const msgX = dino.x + charWidth / 2;
        const msgY = dino.y + CONFIG.FINISH_MESSAGE_OFFSET_Y;
        ctx.fillText(CONFIG.FINISH_MESSAGE, msgX, msgY);
        ctx.textAlign = "left";
        ctx.textBaseline = "alphabetic";
      }
    }

    function drawLayer(tilesArray, prefix, id, fallbackAlpha, targetHeight, alreadyAdjusted){
      const key = `${prefix}${id}.png`;
      const e = imageCache.get(key) || loadImageOnce(key);

      // Adjust tiles once when image loads
      if(e.loaded && e.ok && !alreadyAdjusted){
        adjustLayerForImage(tilesArray, e.width, e.height, targetHeight);
        alreadyAdjusted = true;
      }

      for(const t of tilesArray){
        if(e.loaded && e.ok){
          ctx.drawImage(e.img, t.x, t.y, t.w, t.h);
        }else{
          // Fallback: yellow square with layer-specific alpha
          ctx.globalAlpha = fallbackAlpha;
          ctx.fillStyle = CONFIG.LAYER_FALLBACK_COLOR;
          const s = CONFIG.LAYER_FALLBACK_SIZE;
          const cx = t.x + (t.w - s)/2, cy = t.y + (t.h - s)/2;
          ctx.fillRect(cx, cy, s, s);
          ctx.globalAlpha = 1.0; // reset
        }
      }

      return alreadyAdjusted;
    }

    function drawDino(){
      const frame = Math.floor(state.animTime * 8) % 2;
      const key = `${CONFIG.DINO_PREFIX}${curDinoId}_${frame===0?"a":"b"}.png`;
      const e = imageCache.get(key) || loadImageOnce(key);
      if(e.loaded && e.ok){
        // Use original image size * scale
        const w = e.width * CONFIG.DINO_IMAGE_SCALE;
        const h = e.height * CONFIG.DINO_IMAGE_SCALE;
        ctx.drawImage(e.img, dino.x, dino.y, w, h);
      }else{
        // Fallback: use CONFIG size
        ctx.fillStyle = CONFIG.DINO_FALLBACK_COLOR;
        ctx.fillRect(dino.x, dino.y, dino.w, dino.h);
      }
    }

    function drawObstacle(ob){
      const isAir = !!ob.air;
      const key = isAir
        ? `${CONFIG.AOBST_PREFIX}${curAirId}.png`
        : `${CONFIG.OBST_PREFIX}${curGroundId}.png`;
      const e = imageCache.get(key) || loadImageOnce(key);
      if(e.loaded && e.ok){
        // Use original image size * scale (already calculated in spawn)
        ctx.drawImage(e.img, ob.x, ob.y, ob.w, ob.h);
      }else{
        // Fallback: use obstacle's stored size
        ctx.fillStyle = CONFIG.OBST_FALLBACK_COLOR;
        ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
      }
    }

    // ===============================
    // Boot
    // ===============================
    highScoreEl.textContent = `HIGH SCORE: ${state.highScore}`;
    scoreEl.textContent = `SCORE: 0`;
    resetGame();
  </script>
</body>
</html>