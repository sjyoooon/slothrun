<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>ëŸ°ë‹¹ ëœë¤ ì´ë¯¸ì§€ ë‹¤ì´ë…¸ëŸ°</title>
  <style>
    :root { --bg: #ffffff; }
    * { box-sizing: border-box; }
    body {
      margin: 0; background: var(--bg);
      display: grid; place-items: center; height: 100dvh;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif;
    }
    .wrap { position: relative; width: min(960px, 100vw); padding: 12px; }
    canvas { width: 100%; height: auto; display: block; border: 1px solid #ddd; background: #fff; touch-action: manipulation; }
    .hud {
      pointer-events: none; position: absolute; top: 12px; left: 12px; right: 12px;
      display: flex; justify-content: space-between; font-weight: 700; font-variant-numeric: tabular-nums;
      background: rgba(255,255,255,.0);
    }
    .badge { background: rgba(255,255,255,.85); border: 1px solid #eee; padding: 6px 10px; border-radius: 8px; }
    #overlay { position: absolute; inset: 0; display: none; place-items: center; }
    button {
      appearance: none; border: 0; padding: 12px 16px; border-radius: 10px;
      background: #111; color: #fff; font-weight: 700; cursor: pointer; box-shadow: 0 4px 12px rgba(0,0,0,.15);
    }
    button:active { transform: translateY(1px); }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div id="highScore" class="badge">ìµœê³ ì : 0</div>
      <div id="score" class="badge">ì ìˆ˜: 0</div>
    </div>
    <canvas id="game" width="900" height="260"></canvas>
    <div id="overlay"><button id="restartBtn">ì¬ì‹œì‘</button></div>
  </div>

  <script>
    // ===============================
    // ğŸ”§ CONFIG (ì›í•˜ëŠ” ê°’ ì—¬ê¸°ì„œ ì¡°ì •)
    // ===============================
    const CONFIG = {
      GAME_WIDTH: 900,
      GAME_HEIGHT: 260,

      // ì§€ë©´/í”Œë ˆì´ì–´
      GROUND_Y: 220,
      DINO_X: 60,
      DINO_WIDTH: 36,
      DINO_HEIGHT: 42,
      DINO_FALLBACK_COLOR: "#000000",
      JUMP_VELOCITY: -520, // px/s (ìŒìˆ˜=ìœ„)
      GRAVITY: 1600,       // px/s^2

      // ê²Œì„ ì†ë„
      SPEED_START: 280,        // ì§€ë©´ ê¸°ì¤€ ì§„í–‰ ì†ë„(px/s)
      SPEED_ACCEL_PER_SEC: 18, // ì´ˆë‹¹ ê°€ì†
      SPEED_MAX: 780,

      // ì¥ì• ë¬¼ (íˆíŠ¸ë°•ìŠ¤=ë Œë” í¬ê¸°)
      OBST_MIN_GAP: 220,
      OBST_MAX_GAP: 420,
      OBST_WIDTH: 30,
      OBST_HEIGHT: 50,
      OBST_FALLBACK_COLOR: "#e53935",

      // ì ìˆ˜
      SCORE_PER_OBSTACLE: 10,
      HIGH_SCORE_KEY: "dinoHighScore_runRandom_v1",

      // ğŸ”½ íŒŒì¼ ì„¸íŠ¸ ì§€ì • (ëŸ° ì‹œì‘ ì‹œ 1íšŒ ëœë¤ ì„ íƒ, ëŸ° ë™ì•ˆ ê³ ì •)
      // ìºë¦­í„°: sloth{ID}_a.png / sloth{ID}_b.png
      DINO_IDS: ["01","02","03"],
      DINO_PREFIX: "sloth",
      // ì¥ì• ë¬¼: prop{ID}.png
      OBST_IDS: ["01","02","03"],
      OBST_PREFIX: "prop",
      // ë°°ê²½: bg{ID}.png (ê°€ë¡œ ë°˜ë³µ ìŠ¤í¬ë¡¤, 3íƒ€ì¼)
      BG_IDS: ["01","02","03"],
      BG_PREFIX: "bg",
      // êµ¬ë¦„: cloud{ID}.png (ì—¬ëŸ¬ ê°œ ìŠ¤í°ë˜ì§€ë§Œ ê°™ì€ ì´ë¯¸ì§€ ì‚¬ìš©)
      CLOUD_IDS: ["01","02","03"],
      CLOUD_PREFIX: "cloud",

      // ì• ë‹ˆë©”ì´ì…˜
      DINO_ANIM_FPS: 8,

      // ë°°ê²½ ìŠ¤í¬ë¡¤ (ë°°ê²½ì€ ì´ë¯¸ì§€ ìˆë“  ì—†ë“  ì´ í¬ê¸°ë¡œ ê·¸ë ¤ì„œ ë§ì¶¤)
      BG_DRAW_WIDTH: 400,      // ë°°ê²½ íƒ€ì¼ í•˜ë‚˜ì˜ ê°€ë¡œ
      BG_DRAW_HEIGHT: 180,     // ë°°ê²½ íƒ€ì¼ í•˜ë‚˜ì˜ ì„¸ë¡œ
      BG_Y: 40,                // ë°°ê²½ íƒ€ì¼ ìƒë‹¨ Y
      BG_SCROLL_PARALLAX: 0.5, // ì§€ë©´ ì†ë„ ëŒ€ë¹„ ë°°ê²½ ì†ë„ ë¹„ìœ¨ (0.5 = ì ˆë°˜)
      BG_FALLBACK_COLOR: "#ffd54f", // ë…¸ë€ ì •ì‚¬ê° (ì—†ì„ ë•Œ)
      BG_FALLBACK_SIZE: 80,    // ë…¸ë€ ì •ì‚¬ê° í•œ ë³€ ê¸¸ì´ (íƒ€ì¼ ì•ˆì— ê°€ìš´ë° ë°°ì¹˜)

      // êµ¬ë¦„
      CLOUD_SPAWN_SEC_MIN: 1.2,
      CLOUD_SPAWN_SEC_MAX: 2.6,
      CLOUD_SPEED_MIN: 40,   // px/s
      CLOUD_SPEED_MAX: 90,   // px/s
      CLOUD_Y_MIN: 20,
      CLOUD_Y_MAX: 100,
      CLOUD_WIDTH: 64,
      CLOUD_HEIGHT: 40,
      CLOUD_FALLBACK_COLOR: "#43a047", // ì´ˆë¡ ì •ì‚¬ê°
      CLOUD_FALLBACK_SIZE: 24
    };

    // ===============================
    // ìº”ë²„ìŠ¤ & UI
    // ===============================
    const cvs = document.getElementById("game");
    const ctx = cvs.getContext("2d");
    const scoreEl = document.getElementById("score");
    const highScoreEl = document.getElementById("highScore");
    const overlay = document.getElementById("overlay");
    const restartBtn = document.getElementById("restartBtn");
    cvs.width = CONFIG.GAME_WIDTH;
    cvs.height = CONFIG.GAME_HEIGHT;

    // ===============================
    // ìƒíƒœ
    // ===============================
    const state = {
      running:false, dead:false,
      speed: CONFIG.SPEED_START,
      lastTime: 0,
      score: 0,
      highScore: Number(localStorage.getItem(CONFIG.HIGH_SCORE_KEY) || 0),
      animTime: 0,
      distSinceLast: 0
    };

    // ìºë¦­í„°
    const dino = { x: CONFIG.DINO_X, y: CONFIG.GROUND_Y - CONFIG.DINO_HEIGHT, w: CONFIG.DINO_WIDTH, h: CONFIG.DINO_HEIGHT, vy: 0, onGround: true, id: null };

    // ì¥ì• ë¬¼ / êµ¬ë¦„ / ë°°ê²½
    /** @type {Array<{x:number,y:number,w:number,h:number,scored?:boolean}>} */
    let obstacles = [];
    /** @type {Array<{x:number,y:number,w:number,h:number,speed:number}>} */
    let clouds = [];
    /** ë°°ê²½ íƒ€ì¼ 3ê°œ */
    let bgTiles = []; // {x,y,w,h}
    let randGap = 0;

    // ì´ë²ˆ ëŸ°ì— ê³ ì •ë˜ëŠ” ì„ íƒë“¤
    let currentDinoId = null;    // e.g., "01"
    let currentObstId = null;    // e.g., "02"
    let currentBgId = null;      // e.g., "03"
    let currentCloudId = null;   // e.g., "01"

    // êµ¬ë¦„ ìŠ¤í° íƒ€ì´ë¨¸
    let cloudSpawnTimer = 0;
    let cloudSpawnNext = 0;

    // ===============================
    // ë¡œë”
    // ===============================
    const imageCache = new Map(); // key -> {img, ok, loaded}
    function loadImageOnce(src){
      if(imageCache.has(src)) return imageCache.get(src);
      const e = { img: new Image(), ok: false, loaded: false };
      e.img.onload = ()=>{ e.ok = true; e.loaded = true; };
      e.img.onerror = ()=>{ e.ok = false; e.loaded = true; };
      e.img.src = src;
      imageCache.set(src, e);
      return e;
    }

    // ìœ í‹¸
    const pickRandom = arr => arr[(Math.random()*arr.length)|0];
    const randInt = (a,b) => Math.floor(Math.random()*(b-a+1))+a;
    const randFloat = (a,b) => Math.random()*(b-a)+a;
    const clamp = (v,a,b) => Math.max(a, Math.min(b,v));
    const rectsOverlap = (ax,ay,aw,ah,bx,by,bw,bh)=> ax<bx+bw && ax+aw>bx && ay<by+bh && ay+ah>by;

    // ===============================
    // ì„ íƒ & í”„ë¦¬ë¡œë“œ (ëŸ° ì‹œì‘ë§ˆë‹¤)
    // ===============================
    function chooseRunAssets(){
      // ìºë¦­í„°
      currentDinoId = pickRandom(CONFIG.DINO_IDS);
      loadImageOnce(`${CONFIG.DINO_PREFIX}${currentDinoId}_a.png`);
      loadImageOnce(`${CONFIG.DINO_PREFIX}${currentDinoId}_b.png`);
      dino.id = currentDinoId;

      // ì¥ì• ë¬¼
      currentObstId = pickRandom(CONFIG.OBST_IDS);
      loadImageOnce(`${CONFIG.OBST_PREFIX}${currentObstId}.png`);

      // ë°°ê²½
      currentBgId = pickRandom(CONFIG.BG_IDS);
      loadImageOnce(`${CONFIG.BG_PREFIX}${currentBgId}.png`);

      // êµ¬ë¦„
      currentCloudId = pickRandom(CONFIG.CLOUD_IDS);
      loadImageOnce(`${CONFIG.CLOUD_PREFIX}${currentCloudId}.png`);
    }

    // ===============================
    // ì´ˆê¸°í™”/ë¦¬ì…‹
    // ===============================
    function resetGame(){
      state.running = true; state.dead = false;
      state.speed = CONFIG.SPEED_START; state.lastTime = performance.now();
      state.score = 0; state.animTime = 0; state.distSinceLast = 0;

      dino.x = CONFIG.DINO_X;
      dino.y = CONFIG.GROUND_Y - dino.h;
      dino.vy = 0; dino.onGround = true;

      chooseRunAssets();

      // ì¥ì• ë¬¼ & êµ¬ë¦„ & ë°°ê²½ ì´ˆê¸°í™”
      obstacles = [];
      clouds = [];
      randGap = randInt(CONFIG.OBST_MIN_GAP, CONFIG.OBST_MAX_GAP);

      // ë°°ê²½ íƒ€ì¼ 3ê°œ ì„¸íŒ…
      bgTiles = [];
      const w = CONFIG.BG_DRAW_WIDTH, h = CONFIG.BG_DRAW_HEIGHT, y = CONFIG.BG_Y;
      bgTiles.push({ x: 0,         y, w, h });
      bgTiles.push({ x: w,         y, w, h });
      bgTiles.push({ x: w * 2,     y, w, h });

      // êµ¬ë¦„ ìŠ¤í° íƒ€ì´ë¨¸
      cloudSpawnTimer = 0;
      cloudSpawnNext = randFloat(CONFIG.CLOUD_SPAWN_SEC_MIN, CONFIG.CLOUD_SPAWN_SEC_MAX);

      overlay.style.display = "none";
      scoreEl.textContent = `ì ìˆ˜: ${state.score}`;
      highScoreEl.textContent = `ìµœê³ ì : ${state.highScore}`;

      requestAnimationFrame(loop);
    }

    function gameOver(){
      state.dead = true; state.running = false;
      if(state.score > state.highScore){
        state.highScore = state.score;
        localStorage.setItem(CONFIG.HIGH_SCORE_KEY, String(state.highScore));
      }
      highScoreEl.textContent = `ìµœê³ ì : ${state.highScore}`;
      overlay.style.display = "grid";
    }

    // ===============================
    // ì¥ì• ë¬¼/êµ¬ë¦„ ìŠ¤í°
    // ===============================
    function trySpawnObstacle(){
      if(state.distSinceLast < randGap) return;
      const w = CONFIG.OBST_WIDTH, h = CONFIG.OBST_HEIGHT;
      obstacles.push({
        x: CONFIG.GAME_WIDTH + w,
        y: CONFIG.GROUND_Y - h,
        w, h, scored:false
      });
      state.distSinceLast = 0;
      randGap = randInt(CONFIG.OBST_MIN_GAP, CONFIG.OBST_MAX_GAP);
    }

    function trySpawnCloud(dt){
      cloudSpawnTimer += dt;
      if(cloudSpawnTimer < cloudSpawnNext) return;

      cloudSpawnTimer = 0;
      cloudSpawnNext = randFloat(CONFIG.CLOUD_SPAWN_SEC_MIN, CONFIG.CLOUD_SPAWN_SEC_MAX);

      const y = randInt(CONFIG.CLOUD_Y_MIN, CONFIG.CLOUD_Y_MAX);
      const speed = randFloat(CONFIG.CLOUD_SPEED_MIN, CONFIG.CLOUD_SPEED_MAX);
      clouds.push({
        x: CONFIG.GAME_WIDTH + CONFIG.CLOUD_WIDTH,
        y, w: CONFIG.CLOUD_WIDTH, h: CONFIG.CLOUD_HEIGHT, speed
      });
    }

    // ===============================
    // ì…ë ¥
    // ===============================
    window.addEventListener("keydown", (e)=>{
      if(e.code==="Space" || e.code==="ArrowUp"){ e.preventDefault(); jump(); }
    }, { passive:false });
    cvs.addEventListener("pointerdown", ()=>{ if(!state.dead) jump(); });
    document.getElementById("restartBtn").addEventListener("click", resetGame);

    function jump(){
      if(!state.running || state.dead) return;
      if(dino.onGround){
        dino.vy = CONFIG.JUMP_VELOCITY;
        dino.onGround = false;
      }
    }

    // ===============================
    // ë£¨í”„
    // ===============================
    function loop(now){
      if(!state.running) return;
      const dt = Math.min(0.032, (now - state.lastTime)/1000);
      state.lastTime = now;
      state.animTime += dt;

      // ì†ë„ ê°€ì†
      state.speed = clamp(state.speed + CONFIG.SPEED_ACCEL_PER_SEC * dt, CONFIG.SPEED_START, CONFIG.SPEED_MAX);

      // ìºë¦­í„° ë¬¼ë¦¬
      dino.vy += CONFIG.GRAVITY * dt;
      dino.y += dino.vy * dt;
      const groundTop = CONFIG.GROUND_Y - dino.h;
      if(dino.y >= groundTop){ dino.y = groundTop; dino.vy = 0; dino.onGround = true; }

      // ì¥ì• ë¬¼/êµ¬ë¦„/ë°°ê²½ ì—…ë°ì´íŠ¸
      state.distSinceLast += state.speed * dt;
      trySpawnObstacle();
      trySpawnCloud(dt);
      updateObstacles(dt);
      updateClouds(dt);
      updateBackground(dt);

      render();
      requestAnimationFrame(loop);
    }

    function updateObstacles(dt){
      for(let i=obstacles.length-1;i>=0;i--){
        const ob = obstacles[i];
        ob.x -= state.speed * dt;

        // ë“ì 
        if(!ob.scored && ob.x + ob.w < dino.x){
          ob.scored = true;
          state.score += CONFIG.SCORE_PER_OBSTACLE;
          scoreEl.textContent = `ì ìˆ˜: ${state.score}`;
        }

        // ì¶©ëŒ
        if(rectsOverlap(dino.x,dino.y,dino.w,dino.h, ob.x,ob.y,ob.w,ob.h)){
          gameOver(); return;
        }

        if(ob.x + ob.w < -50) obstacles.splice(i,1);
      }
    }

    function updateClouds(dt){
      for(let i=clouds.length-1;i>=0;i--){
        const c = clouds[i];
        c.x -= c.speed * dt;
        if(c.x + c.w < -10) clouds.splice(i,1);
      }
    }

    function updateBackground(dt){
      const scroll = state.speed * CONFIG.BG_SCROLL_PARALLAX * dt;
      const tileW = CONFIG.BG_DRAW_WIDTH;
      let maxX = -Infinity;
      for(const t of bgTiles){
        t.x -= scroll;
        if(t.x > maxX) maxX = t.x;
      }
      // ì™¼ìª½ìœ¼ë¡œ ì™„ì „íˆ ë‚˜ê°„ íƒ€ì¼ì€ ì˜¤ë¥¸ìª½ ëìœ¼ë¡œ ì´ë™
      for(const t of bgTiles){
        if(t.x + tileW < 0){
          t.x = maxX + tileW;
          maxX = t.x;
        }
      }
    }

    // ===============================
    // ë Œë”
    // ===============================
    function render(){
      ctx.clearRect(0,0,CONFIG.GAME_WIDTH,CONFIG.GAME_HEIGHT);

      // ë°°ê²½ ë ˆì´ì–´ (ë¨¼ì €)
      drawBackground();

      // êµ¬ë¦„
      for(const c of clouds) drawCloud(c);

      // ì§€ë©´ ë¼ì¸
      ctx.strokeStyle="#ddd";
      ctx.beginPath();
      ctx.moveTo(0, CONFIG.GROUND_Y+0.5);
      ctx.lineTo(CONFIG.GAME_WIDTH, CONFIG.GROUND_Y+0.5);
      ctx.stroke();

      // ìºë¦­í„°
      drawDino();

      // ì¥ì• ë¬¼
      for(const ob of obstacles) drawObstacle(ob);
    }

    function drawBackground(){
      const key = `${CONFIG.BG_PREFIX}${currentBgId}.png`;
      const e = imageCache.get(key) || loadImageOnce(key);
      for(const t of bgTiles){
        if(e.loaded && e.ok){
          ctx.drawImage(e.img, t.x, t.y, t.w, t.h);
        }else{
          // ë…¸ë€ ì •ì‚¬ê° (íƒ€ì¼ ì¤‘ì•™)
          ctx.fillStyle = CONFIG.BG_FALLBACK_COLOR;
          const s = CONFIG.BG_FALLBACK_SIZE;
          const cx = t.x + (t.w - s)/2;
          const cy = t.y + (t.h - s)/2;
          ctx.fillRect(cx, cy, s, s);
          // íƒ€ì¼ ê²½ê³„ì„ (ë””ë²„ê·¸ ì›í•˜ë©´ ì£¼ì„í•´ì œ)
          // ctx.strokeStyle="#ffe082"; ctx.strokeRect(t.x,t.y,t.w,t.h);
        }
      }
    }

    function drawCloud(c){
      const key = `${CONFIG.CLOUD_PREFIX}${currentCloudId}.png`;
      const e = imageCache.get(key) || loadImageOnce(key);
      if(e.loaded && e.ok){
        ctx.drawImage(e.img, c.x, c.y, c.w, c.h);
      }else{
        ctx.fillStyle = CONFIG.CLOUD_FALLBACK_COLOR;
        const s = CONFIG.CLOUD_FALLBACK_SIZE;
        const cx = c.x + (c.w - s)/2;
        const cy = c.y + (c.h - s)/2;
        ctx.fillRect(cx, cy, s, s);
      }
    }

    function drawDino(){
      const frame = Math.floor(state.animTime * CONFIG.DINO_ANIM_FPS) % 2; // 0/1
      const key = `${CONFIG.DINO_PREFIX}${currentDinoId}_${frame===0?"a":"b"}.png`;
      const e = imageCache.get(key) || loadImageOnce(key);
      if(e.loaded && e.ok){
        ctx.drawImage(e.img, dino.x, dino.y, dino.w, dino.h);
      }else{
        ctx.fillStyle = CONFIG.DINO_FALLBACK_COLOR;
        ctx.fillRect(dino.x, dino.y, dino.w, dino.h);
      }
    }

    function drawObstacle(ob){
      const key = `${CONFIG.OBST_PREFIX}${currentObstId}.png`;
      const e = imageCache.get(key) || loadImageOnce(key);
      if(e.loaded && e.ok){
        ctx.drawImage(e.img, ob.x, ob.y, ob.w, ob.h);
      }else{
        ctx.fillStyle = CONFIG.OBST_FALLBACK_COLOR;
        ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
      }
    }

    // ===============================
    // ì‹œì‘
    // ===============================
    highScoreEl.textContent = `ìµœê³ ì : ${state.highScore}`;
    resetGame();
  </script>
</body>
</html>
