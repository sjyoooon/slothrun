<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>ë‹¤ì´ë…¸ëŸ° - ì´ë¯¸ì§€/ë°•ìŠ¤ ìë™ ì „í™˜</title>
  <style>
    body { margin: 0; background: #fff; display: grid; place-items: center; height: 100dvh; font-family: system-ui, sans-serif; }
    .wrap { position: relative; width: min(960px, 100vw); padding: 12px; }
    canvas { width: 100%; height: auto; border: 1px solid #ddd; background: #fff; touch-action: manipulation; display: block; }
    .hud { pointer-events: none; position: absolute; top: 12px; left: 12px; right: 12px; display: flex; justify-content: space-between; font-weight: 700; font-variant-numeric: tabular-nums; }
    .badge { background: rgba(255,255,255,.85); border: 1px solid #eee; padding: 6px 10px; border-radius: 8px; }
    #overlay { position: absolute; inset: 0; display: none; place-items: center; }
    button { padding: 12px 16px; border: 0; border-radius: 10px; background: #111; color: #fff; font-weight: 700; cursor: pointer; }
    button:active { transform: translateY(1px); }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div id="highScore" class="badge">ìµœê³ ì : 0</div>
      <div id="score" class="badge">ì ìˆ˜: 0</div>
    </div>
    <canvas id="game" width="900" height="260"></canvas>
    <div id="overlay"><button id="restartBtn">ì¬ì‹œì‘</button></div>
  </div>

  <script>
    // ===============================
    // ğŸ”§ ì„¤ì • (ì—¬ê¸°ë§Œ ì†ëŒ€ë©´ ë¨)
    // ===============================
    const CONFIG = {
      GAME_WIDTH: 900,
      GAME_HEIGHT: 260,

      // ìºë¦­í„° í¬ê¸°/ìœ„ì¹˜/ë¬¼ë¦¬
      GROUND_Y: 220,
      DINO_X: 60,
      DINO_WIDTH: 36,
      DINO_HEIGHT: 42,
      DINO_FALLBACK_COLOR: "#000000",
      JUMP_VELOCITY: -520,
      GRAVITY: 1600,

      // ì´ë™ ì†ë„
      SPEED_START: 280,
      SPEED_ACCEL_PER_SEC: 18,
      SPEED_MAX: 780,

      // ì¥ì• ë¬¼ ê°„ê²©/í¬ê¸°(íˆíŠ¸ë°•ìŠ¤ = ë Œë” í¬ê¸°)
      OBST_MIN_GAP: 220,
      OBST_MAX_GAP: 420,
      OBST_WIDTH: 30,
      OBST_HEIGHT: 50,
      OBST_FALLBACK_COLOR: "#e53935",

      // ì ìˆ˜
      SCORE_PER_OBSTACLE: 10,
      HIGH_SCORE_KEY: "dinoHighScore_imgRect_v1",

      // ğŸ”½ íŒŒì¼ ì„¸íŠ¸ ì§€ì • (ì›í•˜ëŠ” ë§Œí¼ ì¶”ê°€/ì‚­ì œ)
      // ìºë¦­í„°: sloth{ID}_a.png & sloth{ID}_b.png (ê°™ì€ ê²½ë¡œ)
      DINO_IDS: ["01", "02", "03"],
      DINO_PREFIX: "sloth",
      // ì¥ì• ë¬¼: prop{ID}.png
      OBST_IDS: ["01", "02", "03"],
      OBST_PREFIX: "prop",

      // ì• ë‹ˆë©”ì´ì…˜
      DINO_ANIM_FPS: 8, // ì´ˆë‹¹ í”„ë ˆì„
    };

    // ===============================
    // ìº”ë²„ìŠ¤/ìƒíƒœ
    // ===============================
    const cvs = document.getElementById("game");
    const ctx = cvs.getContext("2d");
    const scoreEl = document.getElementById("score");
    const highScoreEl = document.getElementById("highScore");
    const overlay = document.getElementById("overlay");
    const restartBtn = document.getElementById("restartBtn");

    cvs.width = CONFIG.GAME_WIDTH;
    cvs.height = CONFIG.GAME_HEIGHT;

    const state = {
      running: false,
      dead: false,
      speed: CONFIG.SPEED_START,
      lastTime: 0,
      score: 0,
      highScore: Number(localStorage.getItem(CONFIG.HIGH_SCORE_KEY) || 0),
      animTime: 0, // ìºë¦­í„° 2í”„ë ˆì„ ì „í™˜ìš©
    };

    const dino = {
      x: CONFIG.DINO_X,
      y: CONFIG.GROUND_Y - CONFIG.DINO_HEIGHT,
      w: CONFIG.DINO_WIDTH,
      h: CONFIG.DINO_HEIGHT,
      vy: 0,
      onGround: true,
      // í˜„ì¬ ì„ íƒëœ ë³€í˜• ID (e.g., "01")
      id: null,
    };

    /** ì¥ì• ë¬¼: {x,y,w,h,scored:boolean,id:string|null} */
    let obstacles = [];
    let randGap = randInt(CONFIG.OBST_MIN_GAP, CONFIG.OBST_MAX_GAP);

    // ===============================
    // ì´ë¯¸ì§€ ë¡œë” (ìˆëŠ” íŒŒì¼ë§Œ ì“°ê³ , ì—†ìœ¼ë©´ ë°•ìŠ¤)
    // ===============================
    const imageCache = new Map(); // key -> {img, ok:boolean, loaded:boolean}
    function loadImageOnce(src) {
      if (imageCache.has(src)) return imageCache.get(src);
      const entry = { img: new Image(), ok: false, loaded: false };
      entry.img.onload = () => { entry.ok = true; entry.loaded = true; };
      entry.img.onerror = () => { entry.ok = false; entry.loaded = true; };
      entry.img.src = src;
      imageCache.set(src, entry);
      return entry;
    }

    function pickRandom(arr) { return arr[(Math.random() * arr.length) | 0]; }
    function randInt(a,b){return Math.floor(Math.random()*(b-a+1))+a;}
    function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
    function rectsOverlap(ax,ay,aw,ah,bx,by,bw,bh){
      return ax<bx+bw&&ax+aw>bx&&ay<by+bh&&ay+ah>by;
    }

    // ìºë¦­í„° ë³€í˜• ì„ íƒ + í•„ìš”í•œ ë‘ í”„ë ˆì„ ì„ ë¡œë”©
    function chooseDinoVariant() {
      if (!CONFIG.DINO_IDS.length) { dino.id = null; return; }
      dino.id = pickRandom(CONFIG.DINO_IDS);
      const base = `${CONFIG.DINO_PREFIX}${dino.id}`;
      loadImageOnce(`${base}_a.png`);
      loadImageOnce(`${base}_b.png`);
    }

    // ì¥ì• ë¬¼ ìƒì„± ì‹œ ë³€í˜• ì„ íƒ + ì„ ë¡œë”©
    function chooseObstacleId() {
      if (!CONFIG.OBST_IDS.length) return null;
      const id = pickRandom(CONFIG.OBST_IDS);
      const src = `${CONFIG.OBST_PREFIX}${id}.png`;
      loadImageOnce(src);
      return id;
    }

    // ===============================
    // ê²Œì„ ì œì–´
    // ===============================
    function resetGame() {
      state.running = true; state.dead = false;
      state.speed = CONFIG.SPEED_START;
      state.lastTime = performance.now();
      state.score = 0; state.animTime = 0;

      dino.y = CONFIG.GROUND_Y - CONFIG.DINO_HEIGHT;
      dino.vy = 0; dino.onGround = true;
      chooseDinoVariant();

      obstacles = [];
      randGap = randInt(CONFIG.OBST_MIN_GAP, CONFIG.OBST_MAX_GAP);

      overlay.style.display = "none";
      scoreEl.textContent = `ì ìˆ˜: ${state.score}`;
      highScoreEl.textContent = `ìµœê³ ì : ${state.highScore}`;

      requestAnimationFrame(loop);
    }

    function gameOver() {
      state.dead = true; state.running = false;
      if (state.score > state.highScore) {
        state.highScore = state.score;
        localStorage.setItem(CONFIG.HIGH_SCORE_KEY, String(state.highScore));
      }
      highScoreEl.textContent = `ìµœê³ ì : ${state.highScore}`;
      overlay.style.display = "grid";
    }

    function trySpawnObstacle() {
      if (state.speed <= 0) return;
      if (state.distSinceLast < randGap) return;

      const w = CONFIG.OBST_WIDTH, h = CONFIG.OBST_HEIGHT;
      const x = CONFIG.GAME_WIDTH + w;
      const y = CONFIG.GROUND_Y - h;
      const id = chooseObstacleId();

      obstacles.push({ x, y, w, h, scored: false, id });
      state.distSinceLast = 0;
      randGap = randInt(CONFIG.OBST_MIN_GAP, CONFIG.OBST_MAX_GAP);
    }

    function addScoreIfPassed(ob) {
      if (!ob.scored && ob.x + ob.w < dino.x) {
        ob.scored = true;
        state.score += CONFIG.SCORE_PER_OBSTACLE;
        scoreEl.textContent = `ì ìˆ˜: ${state.score}`;
      }
    }

    function jump() {
      if (!state.running || state.dead) return;
      if (dino.onGround) {
        dino.vy = CONFIG.JUMP_VELOCITY;
        dino.onGround = false;
      }
    }

    // ===============================
    // ì…ë ¥
    // ===============================
    window.addEventListener("keydown", (e) => {
      if (e.code === "Space" || e.code === "ArrowUp") {
        e.preventDefault();
        jump();
      }
    }, { passive: false });

    cvs.addEventListener("pointerdown", () => { if (!state.dead) jump(); });
    restartBtn.addEventListener("click", resetGame);

    // ===============================
    // ë£¨í”„
    // ===============================
    function loop(now) {
      if (!state.running) return;

      const dt = Math.min(0.032, (now - state.lastTime) / 1000);
      state.lastTime = now;
      state.animTime += dt;

      // ê°€ì†
      state.speed = clamp(state.speed + CONFIG.SPEED_ACCEL_PER_SEC * dt, CONFIG.SPEED_START, CONFIG.SPEED_MAX);

      // ìºë¦­í„° ë¬¼ë¦¬
      dino.vy += CONFIG.GRAVITY * dt;
      dino.y += dino.vy * dt;
      const groundTop = CONFIG.GROUND_Y - dino.h;
      if (dino.y >= groundTop) { dino.y = groundTop; dino.vy = 0; dino.onGround = true; }

      // ì¥ì• ë¬¼ ì´ë™/ìŠ¤í°
      state.distSinceLast = (state.distSinceLast || 0) + state.speed * dt;
      trySpawnObstacle();

      for (let i = obstacles.length - 1; i >= 0; i--) {
        const ob = obstacles[i];
        ob.x -= state.speed * dt;

        addScoreIfPassed(ob);

        if (rectsOverlap(dino.x, dino.y, dino.w, dino.h, ob.x, ob.y, ob.w, ob.h)) {
          gameOver(); render(); return;
        }
        if (ob.x + ob.w < -50) obstacles.splice(i, 1);
      }

      render();
      requestAnimationFrame(loop);
    }

    // ===============================
    // ë Œë”
    // ===============================
    function render() {
      // ë°°ê²½
      ctx.clearRect(0,0,CONFIG.GAME_WIDTH,CONFIG.GAME_HEIGHT);
      // ì§€ë©´ ë¼ì¸
      ctx.strokeStyle = "#ddd";
      ctx.beginPath();
      ctx.moveTo(0, CONFIG.GROUND_Y + 0.5);
      ctx.lineTo(CONFIG.GAME_WIDTH, CONFIG.GROUND_Y + 0.5);
      ctx.stroke();

      // ìºë¦­í„° (ì´ë¯¸ì§€ ìˆìœ¼ë©´ drawImage, ì•„ë‹ˆë©´ ë°•ìŠ¤)
      drawDino();

      // ì¥ì• ë¬¼
      for (const ob of obstacles) drawObstacle(ob);
    }

    function drawDino() {
      const id = dino.id;
      const frameIndex = Math.floor(state.animTime * CONFIG.DINO_ANIM_FPS) % 2; // 0/1
      if (id) {
        const base = `${CONFIG.DINO_PREFIX}${id}`;
        const key = `${base}_${frameIndex === 0 ? "a" : "b"}.png`;
        const e = imageCache.get(key) || loadImageOnce(key);
        if (e.loaded && e.ok) {
          ctx.drawImage(e.img, dino.x, dino.y, dino.w, dino.h);
          return;
        }
        // ë¡œë”© ì¤‘ì´ê±°ë‚˜ ì‹¤íŒ¨ â†’ ë°•ìŠ¤ í‘œì‹œ
      }
      ctx.fillStyle = CONFIG.DINO_FALLBACK_COLOR;
      ctx.fillRect(dino.x, dino.y, dino.w, dino.h);
    }

    function drawObstacle(ob) {
      if (ob.id) {
        const key = `${CONFIG.OBST_PREFIX}${ob.id}.png`;
        const e = imageCache.get(key) || loadImageOnce(key);
        if (e.loaded && e.ok) {
          ctx.drawImage(e.img, ob.x, ob.y, ob.w, ob.h);
          return;
        }
      }
      ctx.fillStyle = CONFIG.OBST_FALLBACK_COLOR;
      ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
    }

    // ===============================
    // ì‹œì‘
    // ===============================
    highScoreEl.textContent = `ìµœê³ ì : ${state.highScore}`;
    resetGame();

  </script>
</body>
</html>
