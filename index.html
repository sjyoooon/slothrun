<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>Beam Run</title>
  <style>
    :root { --bg:#ffffff; }

    /* Prevent selection/scroll/zoom gestures; whole page is input surface */
    html, body {
      margin: 0;
      height: 100%;
      background: var(--bg);
      overflow: hidden;           /* no page scroll */
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;         /* disable browser gestures */
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans", Arial, sans-serif;
    }

    * { box-sizing: border-box; }

    .wrap {
      position: relative;
      width: min(960px, 100vw);
      margin: 0 auto;
      padding: 12px;
      display: grid;
      place-items: center;
      height: 100dvh;
    }

    .game-container {
      position: relative;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0;
    }

    canvas {
      width: 100%;
      height: auto;
      display: block;
      background: #fff;
      touch-action: none;       /* ensure pointer events go to game */
      user-select: none;
    }

    .hud {
      pointer-events: none;
      position: absolute;
      top: 0; left: 0; right: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-weight: 700; font-variant-numeric: tabular-nums;
      z-index: 10;
    }
    .badge {
      background: transparent;
      padding: 6px 10px;
    }

    #overlay {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      top: 0;
      display: none;
      align-items: flex-end;
      justify-content: center;
      pointer-events: none;
    }
    #restartBtn {
      appearance: none; border: 0; border-radius: 10px;
      background: #111; color: #fff; font-weight: 700; cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,.15);
      display: inline-grid; place-items: center;
      pointer-events: auto;
      position: relative;
    }
    #restartBtn:active { transform: translateY(1px); }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="game-container">
      <div class="hud">
        <div id="highScore" class="badge">HIGH SCORE: 0</div>
        <div id="score" class="badge">SCORE: 0</div>
      </div>

      <canvas id="game" width="900" height="600" aria-label="Beam Run"></canvas>

      <div id="overlay">
        <button id="restartBtn" aria-label="Restart">Restart</button>
      </div>
    </div>
  </div>

  <script>
    // ===============================
    // CONFIG — tweak freely
    // ===============================
    const CONFIG = {
      GAME_WIDTH: 800,
      GAME_HEIGHT: 1000,

      // Player / ground
      GROUND_Y: 500,
      GROUND_LINE_WIDTH: 2,    // px (ground line thickness)
      DINO_X: 60,
      DINO_WIDTH: 72,
      DINO_HEIGHT: 84,

      // Character hitbox (rectangle collision for character)
      // Values are relative to character position (0 = left/top edge)
      DINO_HITBOX_OFFSET_X: 45,    // px from left
      DINO_HITBOX_OFFSET_Y: 35,     // px from top
      DINO_HITBOX_WIDTH: 30,       // px
      DINO_HITBOX_HEIGHT: 50,      // px

      // Image sets (chosen once per run)
      DINO_PREFIX: "sloth",     DINO_IDS: ["01"],     // sloth01_a.png / sloth01_b.png ...
      OBST_PREFIX: "prop",      OBST_IDS: ["01"],     // ground:  prop01.png ...
      AOBST_PREFIX: "propair",  AOBST_IDS: ["01","02","03"],    // air:     propair01.png ...

      // Image scale multipliers (applied to actual image size)
      DINO_IMAGE_SCALE: 1.0,     // 1.0 = 100%, 0.5 = 50%, 2.0 = 200%, etc.
      OBST_IMAGE_SCALE: 1.0,
      AOBST_IMAGE_SCALE: 1.0,

      // Fallbacks (when images missing)
      DINO_FALLBACK_COLOR: "#000000",
      OBST_FALLBACK_COLOR: "#e53935",

      // Feature toggles
      ENABLE_AIR_OBSTACLES: false,      // Enable/disable air obstacles
      ENABLE_SCROLL_BACKGROUND: false,  // Enable/disable parallax background layers
      SHOW_HITBOX: false,               // Show hitbox visualization (green semi-transparent box)

      // ===== 4-Layer Parallax Background =====
      // Layer 1: Far Background (원경 - 가장 느림)
      LAYER_FAR_PREFIX: "bgfar",
      LAYER_FAR_IDS: ["01","02","03"],
      LAYER_FAR_SCROLL_PARALLAX: 0.2,     // slowest
      LAYER_FAR_DRAW_WIDTH: 400,
      LAYER_FAR_DRAW_HEIGHT: 180,
      LAYER_FAR_Y: 40,
      LAYER_FAR_FALLBACK_ALPHA: 0.3,

      // Layer 2: Background (배경)
      LAYER_BG_PREFIX: "bg",
      LAYER_BG_IDS: ["01","02","03"],
      LAYER_BG_SCROLL_PARALLAX: 0.4,
      LAYER_BG_DRAW_WIDTH: 400,
      LAYER_BG_DRAW_HEIGHT: 180,
      LAYER_BG_Y: 40,
      LAYER_BG_FALLBACK_ALPHA: 0.5,

      // Layer 3: Midground (중경)
      LAYER_MID_PREFIX: "bgmid",
      LAYER_MID_IDS: ["01","02","03"],
      LAYER_MID_SCROLL_PARALLAX: 0.6,
      LAYER_MID_DRAW_WIDTH: 400,
      LAYER_MID_DRAW_HEIGHT: 180,
      LAYER_MID_Y: 40,
      LAYER_MID_FALLBACK_ALPHA: 0.7,

      // Layer 4: Foreground (전경 - 가장 빠름)
      LAYER_FORE_PREFIX: "bgfore",
      LAYER_FORE_IDS: ["01","02","03"],
      LAYER_FORE_SCROLL_PARALLAX: 0.8,    // fastest
      LAYER_FORE_DRAW_WIDTH: 400,
      LAYER_FORE_DRAW_HEIGHT: 180,
      LAYER_FORE_Y: 40,
      LAYER_FORE_FALLBACK_ALPHA: 0.9,

      // Shared fallback settings for all layers
      LAYER_FALLBACK_COLOR: "#ffd54f",    // yellow
      LAYER_FALLBACK_SIZE: 80,

      // Score
      SCORE_PER_OBSTACLE: 10,
      HIGH_SCORE_KEY: "dino_highscore_touch_v1",

      // Score display settings
      SCORE_FONT_SIZE: 16,        // px
      SCORE_Y_POSITION: 50,       // px from top
      HIGHSCORE_Y_POSITION: 20,   // px from top

      // ===== Scroll speed curve (affects obstacles & background) =====
      SPEED_BASE: 280,        // px/s (base)
      SPEED_MAX_MULT: 3,    // max multiplier (final speed = base * this)
      SPEED_RAMP_SECONDS: 70, // seconds to reach max multiplier (linear)

      // ===== Obstacle spawn =====
      OBST_WIDTH: 30,
      OBST_HEIGHT: 50,
      OBST_MIN_GAP: 220,      // min distance (px) to next spawn
      OBST_MAX_GAP: 520,      // max distance (px) to next spawn

      // Obstacle size multipliers (min/max for random variation)
      OBST_SIZE_MULTIPLIER_MIN: 1.0,
      OBST_SIZE_MULTIPLIER_MAX: 1.0,
      AOBST_SIZE_MULTIPLIER_MIN: 1.0,
      AOBST_SIZE_MULTIPLIER_MAX: 1.0,

      // Air obstacle (mutually exclusive with ground; probability based)
      AIR_OBST_PROB: 35,      // 0~100 (% chance to spawn air obstacle instead)
      AIR_OBST_Y: 160,        // top Y of the air obstacle (fixed height line)

      // ===== Variable jump (hold) =====
      JUMP_MIN_HEIGHT: 150,    // px
      JUMP_MAX_HEIGHT: 250,   // px
      JUMP_MIN_HOLD: 0.05,    // s  (<= -> min height)
      JUMP_MAX_HOLD: 0.25,    // s  (>= -> max height)
      GRAVITY: 4000,          // px/s^2

      // ===== Restart button size =====
      RESTART_BTN_WIDTH: 140, // px
      RESTART_BTN_HEIGHT: 48, // px
      RESTART_BTN_OFFSET_Y: 20, // px from bottom of game area (outside)

      // ===== Lyrics spawn system =====
      LYRICS_TEXT: "SLOTH RUN   KEEP GOING   NEVER STOP",
      LYRICS_FONT_SIZE: 80,
      LYRICS_FONT_BOLD: false,  // Set to true for bold lyrics
      LYRICS_SPACE_MULTIPLIER: 1.5,
      LYRICS_Y: 600,  // Y position for spawned lyrics (above game area)

      // ===== Finish message (displayed on character when game ends) =====
      FINISH_MESSAGE: "I'm full",
      FINISH_MESSAGE_OFFSET_X: 0,   // px offset from character center
      FINISH_MESSAGE_OFFSET_Y: -40, // px offset from character top (negative = above)
      FINISH_MESSAGE_FONT_SIZE: 28,
      FINISH_MESSAGE_COLOR: "#ff6b35"
    };

    // ===============================
    // Canvas & UI
    // ===============================
    const cvs = document.getElementById("game");
    const ctx = cvs.getContext("2d");
    const scoreEl = document.getElementById("score");
    const highScoreEl = document.getElementById("highScore");
    const overlay = document.getElementById("overlay");
    const restartBtn = document.getElementById("restartBtn");
    cvs.width = CONFIG.GAME_WIDTH; cvs.height = CONFIG.GAME_HEIGHT;

    // Apply restart button size and position from CONFIG
    restartBtn.style.width = CONFIG.RESTART_BTN_WIDTH + "px";
    restartBtn.style.height = CONFIG.RESTART_BTN_HEIGHT + "px";
    restartBtn.style.bottom = CONFIG.RESTART_BTN_OFFSET_Y + "px";

    // Apply score display settings from CONFIG
    highScoreEl.style.fontSize = CONFIG.SCORE_FONT_SIZE + "px";
    highScoreEl.style.marginTop = CONFIG.HIGHSCORE_Y_POSITION + "px";
    scoreEl.style.fontSize = CONFIG.SCORE_FONT_SIZE + "px";
    scoreEl.style.marginTop = (CONFIG.SCORE_Y_POSITION - CONFIG.HIGHSCORE_Y_POSITION) + "px";

    // ===============================
    // Helpers
    // ===============================
    const imageCache = new Map();
    function loadImageOnce(src){
      if(imageCache.has(src)) return imageCache.get(src);
      const e = { img:new Image(), ok:false, loaded:false, width:0, height:0, pixelData:null };
      e.img.onload = ()=>{
        e.ok=true;
        e.loaded=true;
        e.width = e.img.naturalWidth;
        e.height = e.img.naturalHeight;
        // Extract pixel data for alpha-based collision detection
        extractPixelData(e);
      };
      e.img.onerror = ()=>{ e.ok=false; e.loaded=true; };
      e.img.src = src;
      imageCache.set(src, e);
      return e;
    }

    // Extract pixel data from loaded image for alpha-based collision
    function extractPixelData(entry){
      if(!entry.ok || !entry.img) return;
      try{
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = entry.width;
        tempCanvas.height = entry.height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(entry.img, 0, 0);
        entry.pixelData = tempCtx.getImageData(0, 0, entry.width, entry.height);
      }catch(err){
        // CORS or other issues - fallback to rect collision
        console.warn('Could not extract pixel data:', err);
      }
    }

    // Check if a pixel has non-transparent alpha (>128 = opaque enough)
    function isPixelOpaque(imageData, x, y){
      if(!imageData || x<0 || y<0 || x>=imageData.width || y>=imageData.height) return false;
      const idx = (Math.floor(y) * imageData.width + Math.floor(x)) * 4;
      return imageData.data[idx + 3] > 128; // alpha channel
    }

    // Alpha-based collision detection between rectangle and image
    // rectX, rectY, rectW, rectH: rectangle hitbox (character)
    // imgX, imgY, imgW, imgH: image position and size (obstacle)
    // imgEntry: image entry with pixel data (obstacle)
    function rectAlphaCollision(rectX, rectY, rectW, rectH, imgX, imgY, imgW, imgH, imgEntry){
      // Calculate overlap rectangle
      const overlapX = Math.max(rectX, imgX);
      const overlapY = Math.max(rectY, imgY);
      const overlapRight = Math.min(rectX + rectW, imgX + imgW);
      const overlapBottom = Math.min(rectY + rectH, imgY + imgH);
      const overlapW = overlapRight - overlapX;
      const overlapH = overlapBottom - overlapY;

      if(overlapW <= 0 || overlapH <= 0) return false;

      // If no pixel data available, fall back to rectangle collision
      if(!imgEntry || !imgEntry.pixelData) return true;

      // Sample pixels in the overlap region (check every few pixels for performance)
      const step = 3; // Check every 3 pixels
      for(let dy = 0; dy < overlapH; dy += step){
        for(let dx = 0; dx < overlapW; dx += step){
          const worldX = overlapX + dx;
          const worldY = overlapY + dy;

          // Map to image coordinates
          const imgPixelX = ((worldX - imgX) / imgW) * imgEntry.width;
          const imgPixelY = ((worldY - imgY) / imgH) * imgEntry.height;

          // Check if pixel is opaque in the obstacle image
          if(isPixelOpaque(imgEntry.pixelData, imgPixelX, imgPixelY)){
            return true; // Collision detected!
          }
        }
      }

      return false; // No opaque pixel overlap
    }

    const pick = arr => arr[(Math.random()*arr.length)|0];
    const randInt = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;
    const randFloat = (a,b)=>Math.random()*(b-a)+a;
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const rectsOverlap=(ax,ay,aw,ah,bx,by,bw,bh)=>ax<bx+bw&&ax+aw>bx&&ay<by+bh&&ay+ah>by;

    // ===============================
    // Per-run selections (fixed during a run)
    // ===============================
    let curDinoId=null, curGroundId=null, curAirId=null;
    let curLayerFarId=null, curLayerBgId=null, curLayerMidId=null, curLayerForeId=null;
    function chooseRunAssets(){
      curDinoId     = pick(CONFIG.DINO_IDS);
      curGroundId   = pick(CONFIG.OBST_IDS);
      curAirId      = pick(CONFIG.AOBST_IDS);
      curLayerFarId = pick(CONFIG.LAYER_FAR_IDS);
      curLayerBgId  = pick(CONFIG.LAYER_BG_IDS);
      curLayerMidId = pick(CONFIG.LAYER_MID_IDS);
      curLayerForeId= pick(CONFIG.LAYER_FORE_IDS);
      // Preload (fallbacks if missing)
      loadImageOnce(`${CONFIG.DINO_PREFIX}${curDinoId}_a.png`);
      loadImageOnce(`${CONFIG.DINO_PREFIX}${curDinoId}_b.png`);
      loadImageOnce(`${CONFIG.OBST_PREFIX}${curGroundId}.png`);
      loadImageOnce(`${CONFIG.AOBST_PREFIX}${curAirId}.png`);
      loadImageOnce(`${CONFIG.LAYER_FAR_PREFIX}${curLayerFarId}.png`);
      loadImageOnce(`${CONFIG.LAYER_BG_PREFIX}${curLayerBgId}.png`);
      loadImageOnce(`${CONFIG.LAYER_MID_PREFIX}${curLayerMidId}.png`);
      loadImageOnce(`${CONFIG.LAYER_FORE_PREFIX}${curLayerForeId}.png`);
    }

    // ===============================
    // Game state
    // ===============================
    const state = {
      running:false, dead:false,
      runStartTime:0, lastTime:0, animTime:0,
      score:0, highScore:Number(localStorage.getItem(CONFIG.HIGH_SCORE_KEY)||0),
      distSinceLast:0
    };

    const dino = {
      x:CONFIG.DINO_X, y:CONFIG.GROUND_Y-CONFIG.DINO_HEIGHT, w:CONFIG.DINO_WIDTH, h:CONFIG.DINO_HEIGHT,
      vy:0, onGround:true,
      holding:false, holdElapsed:0
    };

    // Obstacles / parallax layers
    let obstacles=[]; // {x,y,w,h,scored?:bool, air?:bool}
    let layerFarTiles=[], layerBgTiles=[], layerMidTiles=[], layerForeTiles=[]; // {x,y,w,h}
    let layerFarAdjusted=false, layerBgAdjusted=false, layerMidAdjusted=false, layerForeAdjusted=false;
    let randGap=0;

    // Lyrics spawn system
    let letters=[]; // {char, x, y, w, speed}
    let lyricsIndex=0, elapsedTime=0, nextSpawnTime=0, baseInterval=0;

    // Variable jump precompute
    const v0_min = Math.sqrt(2*CONFIG.GRAVITY*CONFIG.JUMP_MIN_HEIGHT);
    const v0_max = Math.sqrt(2*CONFIG.GRAVITY*CONFIG.JUMP_MAX_HEIGHT);
    const v0_add_total = Math.max(0, v0_max - v0_min);
    const hold_window = Math.max(0.0001, CONFIG.JUMP_MAX_HOLD - CONFIG.JUMP_MIN_HOLD);

    // ===============================
    // Speed curve (base * linear ramp)
    // ===============================
    function currentScrollSpeed(nowMs){
      const t = Math.max(0, (nowMs - state.runStartTime)/1000);
      const r = CONFIG.SPEED_RAMP_SECONDS>0 ? clamp(t/CONFIG.SPEED_RAMP_SECONDS,0,1) : 1;
      const mult = 1 + (CONFIG.SPEED_MAX_MULT - 1) * r;
      return CONFIG.SPEED_BASE * mult;
    }

    // ===============================
    // Reset / Game Over
    // ===============================
    function resetGame(){
      state.running = true; state.dead=false;
      state.runStartTime = performance.now();
      state.lastTime = state.runStartTime;
      state.animTime = 0; state.score=0; state.distSinceLast=0;

      dino.x=CONFIG.DINO_X; dino.y=CONFIG.GROUND_Y-dino.h;
      dino.vy=0; dino.onGround=true; dino.holding=false; dino.holdElapsed=0;

      chooseRunAssets();

      obstacles.length=0;
      layerFarTiles.length=0; layerBgTiles.length=0;
      layerMidTiles.length=0; layerForeTiles.length=0;
      layerFarAdjusted=false; layerBgAdjusted=false;
      layerMidAdjusted=false; layerForeAdjusted=false;
      randGap = randInt(CONFIG.OBST_MIN_GAP, CONFIG.OBST_MAX_GAP);

      // Lyrics system initialization
      letters.length = 0;
      lyricsIndex = 0;
      elapsedTime = 0;
      nextSpawnTime = 0;
      baseInterval = CONFIG.LYRICS_FONT_SIZE / CONFIG.SPEED_BASE;

      // Initialize 4 parallax layers (3 tiles each for seamless scrolling)
      initLayerTiles(layerFarTiles, CONFIG.LAYER_FAR_DRAW_WIDTH, CONFIG.LAYER_FAR_DRAW_HEIGHT, CONFIG.LAYER_FAR_Y);
      initLayerTiles(layerBgTiles, CONFIG.LAYER_BG_DRAW_WIDTH, CONFIG.LAYER_BG_DRAW_HEIGHT, CONFIG.LAYER_BG_Y);
      initLayerTiles(layerMidTiles, CONFIG.LAYER_MID_DRAW_WIDTH, CONFIG.LAYER_MID_DRAW_HEIGHT, CONFIG.LAYER_MID_Y);
      initLayerTiles(layerForeTiles, CONFIG.LAYER_FORE_DRAW_WIDTH, CONFIG.LAYER_FORE_DRAW_HEIGHT, CONFIG.LAYER_FORE_Y);

      overlay.style.display="none";
      scoreEl.textContent = `SCORE: ${state.score}`;
      highScoreEl.textContent = `HIGH SCORE: ${state.highScore}`;
      requestAnimationFrame(loop);
    }

    function gameOver(){
      state.dead=true; state.running=false;
      if(state.score > state.highScore){
        state.highScore = state.score;
        localStorage.setItem(CONFIG.HIGH_SCORE_KEY, String(state.highScore));
      }
      highScoreEl.textContent = `HIGH SCORE: ${state.highScore}`;
      overlay.style.display = "grid";
    }

    // ===============================
    // Layer initialization & scrolling helpers
    // ===============================
    function initLayerTiles(tilesArray, width, height, y){
      tilesArray.push({x:0, y, w:width, h:height});
      tilesArray.push({x:width, y, w:width, h:height});
      tilesArray.push({x:width*2, y, w:width, h:height});
    }

    // Adjust tiles based on actual image size (called once image loads)
    function adjustLayerForImage(tilesArray, imgWidth, imgHeight, targetHeight){
      if(tilesArray.length===0 || !imgWidth || !imgHeight) return;

      // Calculate scaled width maintaining aspect ratio
      const aspectRatio = imgWidth / imgHeight;
      const scaledWidth = targetHeight * aspectRatio;

      // Calculate how many tiles needed to cover screen + buffer
      const tilesNeeded = Math.ceil(CONFIG.GAME_WIDTH / scaledWidth) + 2;

      // Update existing tiles and add more if needed
      const y = tilesArray[0].y;
      tilesArray.length = 0;
      for(let i = 0; i < tilesNeeded; i++){
        tilesArray.push({x: i * scaledWidth, y, w: scaledWidth, h: targetHeight});
      }
    }

    function updateLayerScroll(tilesArray, scrollDelta){
      if(tilesArray.length===0) return;
      const tileW = tilesArray[0].w;
      let maxX = -Infinity;

      // Move all tiles left
      for(const t of tilesArray){
        t.x -= scrollDelta;
        if(t.x > maxX) maxX = t.x;
      }

      // Wrap tiles that moved off-screen to the right
      for(const t of tilesArray){
        if(t.x + tileW < 0){
          t.x = maxX + tileW;
          maxX = t.x;
        }
      }
    }

    // ===============================
    // Spawning
    // ===============================
    function trySpawnObstacle(speed){
      if(state.distSinceLast < randGap) return;

      // If air obstacles disabled, only spawn ground obstacles
      const useAir = CONFIG.ENABLE_AIR_OBSTACLES && (randInt(1,100) <= CONFIG.AIR_OBST_PROB);
      const key = useAir
        ? `${CONFIG.AOBST_PREFIX}${curAirId}.png`
        : `${CONFIG.OBST_PREFIX}${curGroundId}.png`;

      const e = imageCache.get(key) || loadImageOnce(key);

      // Calculate size multiplier (random between min and max)
      const minMult = useAir ? CONFIG.AOBST_SIZE_MULTIPLIER_MIN : CONFIG.OBST_SIZE_MULTIPLIER_MIN;
      const maxMult = useAir ? CONFIG.AOBST_SIZE_MULTIPLIER_MAX : CONFIG.OBST_SIZE_MULTIPLIER_MAX;
      const sizeMult = (minMult === maxMult) ? minMult : randFloat(minMult, maxMult);

      // Use original image size * scale * size multiplier if loaded, otherwise use fallback size
      let w, h;
      if(e.loaded && e.ok && e.width > 0 && e.height > 0){
        const scale = useAir ? CONFIG.AOBST_IMAGE_SCALE : CONFIG.OBST_IMAGE_SCALE;
        w = e.width * scale * sizeMult;
        h = e.height * scale * sizeMult;
      }else{
        w = CONFIG.OBST_WIDTH * sizeMult;
        h = CONFIG.OBST_HEIGHT * sizeMult;
      }

      if(useAir){
        obstacles.push({ x: CONFIG.GAME_WIDTH + w, y: CONFIG.AIR_OBST_Y, w, h, scored:false, air:true });
      }else{
        obstacles.push({ x: CONFIG.GAME_WIDTH + w, y: CONFIG.GROUND_Y - h, w, h, scored:false, air:false });
      }

      state.distSinceLast = 0;
      randGap = randInt(CONFIG.OBST_MIN_GAP, CONFIG.OBST_MAX_GAP);
    }

    // ===============================
    // Input — whole page touch/press for jump
    // ===============================
    let pressActive=false;
    function onPressStart(ev){
      if(state.dead) return;                 // ignore when game over screen
      if(!state.running) return;
      if(dino.onGround && !pressActive){
        pressActive=true; dino.holding=true; dino.holdElapsed=0;
        dino.vy = -v0_min;                   // initial minimal jump impulse
        dino.onGround=false;
      }
    }
    function onPressEnd(ev){
      pressActive=false;
      dino.holding=false;
    }

    // Page-wide pointer listeners (anywhere -> jump)
    window.addEventListener("pointerdown", onPressStart, {passive:false});
    window.addEventListener("pointerup", onPressEnd, {passive:false});

    // Also allow Space/ArrowUp on desktop (optional)
    window.addEventListener("keydown", e=>{
      if(e.code==="Space"||e.code==="ArrowUp"){ e.preventDefault(); onPressStart(); }
    }, {passive:false});
    window.addEventListener("keyup", e=>{
      if(e.code==="Space"||e.code==="ArrowUp"){ e.preventDefault(); onPressEnd(); }
    }, {passive:false});

    // Restart
    document.getElementById("restartBtn").addEventListener("click", resetGame);

    // ===============================
    // Main loop
    // ===============================
    function loop(now){
      if(!state.running) return;
      const dt = Math.min(0.032, (now - state.lastTime)/1000);
      state.lastTime = now;
      state.animTime += dt;

      const speed = currentScrollSpeed(now);
      state.distSinceLast += speed * dt;

      // Variable jump hold — add extra upward velocity while holding
      if(dino.holding && !dino.onGround){
        dino.holdElapsed += dt;
        if(dino.holdElapsed > CONFIG.JUMP_MIN_HOLD){
          const over = Math.min(dino.holdElapsed, CONFIG.JUMP_MAX_HOLD) - CONFIG.JUMP_MIN_HOLD;
          const addRate = (hold_window>0) ? (v0_add_total / hold_window) : 0;
          const dv = addRate * dt;
          dino.vy -= dv; // upward extra impulse (vy negative is up)
          if(dino.holdElapsed >= CONFIG.JUMP_MAX_HOLD) dino.holding=false;
        }
      }

      // Gravity
      dino.vy += CONFIG.GRAVITY * dt;
      dino.y  += dino.vy * dt;

      // Ground collision
      const groundTop = CONFIG.GROUND_Y - dino.h;
      if(dino.y >= groundTop){
        dino.y = groundTop; dino.vy = 0; dino.onGround = true; dino.holding = false;
      }

      // Spawns
      trySpawnObstacle(speed);

      // Lyrics spawn system
      elapsedTime += dt;
      while(lyricsIndex < CONFIG.LYRICS_TEXT.length && elapsedTime >= nextSpawnTime){
        const ch = CONFIG.LYRICS_TEXT[lyricsIndex++];
        if(ch === " "){
          nextSpawnTime += baseInterval * CONFIG.LYRICS_SPACE_MULTIPLIER;
          continue;
        }
        letters.push({
          char: ch,
          x: CONFIG.GAME_WIDTH + CONFIG.LYRICS_FONT_SIZE,
          y: CONFIG.LYRICS_Y,
          w: CONFIG.LYRICS_FONT_SIZE,
          speed: speed
        });
        nextSpawnTime += baseInterval;
      }

      // Lyrics update
      for(let i = letters.length - 1; i >= 0; i--){
        const letter = letters[i];
        letter.x -= speed * dt;
        if(letter.x + letter.w < -10){
          letters.splice(i, 1);
        }
      }

      // Obstacles update
      for(let i=obstacles.length-1;i>=0;i--){
        const ob = obstacles[i];
        ob.x -= speed * dt;

        if(!ob.scored && ob.x + ob.w < dino.x){
          ob.scored = true;
          state.score += CONFIG.SCORE_PER_OBSTACLE;
          scoreEl.textContent = `SCORE: ${state.score}`;
        }

        // Character hitbox (rectangle collision)
        const hitboxX = dino.x + CONFIG.DINO_HITBOX_OFFSET_X;
        const hitboxY = dino.y + CONFIG.DINO_HITBOX_OFFSET_Y;
        const hitboxW = CONFIG.DINO_HITBOX_WIDTH;
        const hitboxH = CONFIG.DINO_HITBOX_HEIGHT;

        // Check collision: character rectangle hitbox vs obstacle alpha pixels
        let collision = false;

        // Get obstacle image
        const isAir = !!ob.air;
        const obKey = isAir
          ? `${CONFIG.AOBST_PREFIX}${curAirId}.png`
          : `${CONFIG.OBST_PREFIX}${curGroundId}.png`;
        const obEntry = imageCache.get(obKey);

        // Use rectangle-alpha collision (character rect vs obstacle alpha pixels)
        collision = rectAlphaCollision(
          hitboxX, hitboxY, hitboxW, hitboxH,
          ob.x, ob.y, ob.w, ob.h, obEntry
        );

        if(collision){
          gameOver(); render(); return;
        }
        if(ob.x + ob.w < -50) obstacles.splice(i,1);
      }

      // Update 4 parallax layers (each with different scroll speed)
      updateLayerScroll(layerFarTiles, speed * CONFIG.LAYER_FAR_SCROLL_PARALLAX * dt);
      updateLayerScroll(layerBgTiles, speed * CONFIG.LAYER_BG_SCROLL_PARALLAX * dt);
      updateLayerScroll(layerMidTiles, speed * CONFIG.LAYER_MID_SCROLL_PARALLAX * dt);
      updateLayerScroll(layerForeTiles, speed * CONFIG.LAYER_FORE_SCROLL_PARALLAX * dt);

      render();
      requestAnimationFrame(loop);
    }

    // ===============================
    // Render
    // ===============================
    function render(){
      ctx.clearRect(0,0,CONFIG.GAME_WIDTH,CONFIG.GAME_HEIGHT);

      // 4 parallax layers (back to front) - only if enabled
      if(CONFIG.ENABLE_SCROLL_BACKGROUND){
        layerFarAdjusted = drawLayer(layerFarTiles, CONFIG.LAYER_FAR_PREFIX, curLayerFarId, CONFIG.LAYER_FAR_FALLBACK_ALPHA, CONFIG.LAYER_FAR_DRAW_HEIGHT, layerFarAdjusted);
        layerBgAdjusted = drawLayer(layerBgTiles, CONFIG.LAYER_BG_PREFIX, curLayerBgId, CONFIG.LAYER_BG_FALLBACK_ALPHA, CONFIG.LAYER_BG_DRAW_HEIGHT, layerBgAdjusted);
        layerMidAdjusted = drawLayer(layerMidTiles, CONFIG.LAYER_MID_PREFIX, curLayerMidId, CONFIG.LAYER_MID_FALLBACK_ALPHA, CONFIG.LAYER_MID_DRAW_HEIGHT, layerMidAdjusted);
        layerForeAdjusted = drawLayer(layerForeTiles, CONFIG.LAYER_FORE_PREFIX, curLayerForeId, CONFIG.LAYER_FORE_FALLBACK_ALPHA, CONFIG.LAYER_FORE_DRAW_HEIGHT, layerForeAdjusted);
      }

      // Ground line
      ctx.strokeStyle="#ddd";
      ctx.lineWidth = CONFIG.GROUND_LINE_WIDTH;
      ctx.beginPath();
      ctx.moveTo(0, CONFIG.GROUND_Y+0.5);
      ctx.lineTo(CONFIG.GAME_WIDTH, CONFIG.GROUND_Y+0.5);
      ctx.stroke();

      // Player
      drawDino();

      // Obstacles
      for(const ob of obstacles) drawObstacle(ob);

      // Hitbox visualization (if enabled)
      if(CONFIG.SHOW_HITBOX){
        // Draw character hitbox
        ctx.strokeStyle = "rgba(0, 255, 0, 0.7)";
        ctx.fillStyle = "rgba(0, 255, 0, 0.2)";
        ctx.lineWidth = 2;
        const hitboxX = dino.x + CONFIG.DINO_HITBOX_OFFSET_X;
        const hitboxY = dino.y + CONFIG.DINO_HITBOX_OFFSET_Y;
        ctx.fillRect(hitboxX, hitboxY, CONFIG.DINO_HITBOX_WIDTH, CONFIG.DINO_HITBOX_HEIGHT);
        ctx.strokeRect(hitboxX, hitboxY, CONFIG.DINO_HITBOX_WIDTH, CONFIG.DINO_HITBOX_HEIGHT);

        // Draw obstacle hitboxes
        ctx.strokeStyle = "rgba(255, 0, 0, 0.7)";
        ctx.fillStyle = "rgba(255, 0, 0, 0.2)";
        for(const ob of obstacles){
          ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
          ctx.strokeRect(ob.x, ob.y, ob.w, ob.h);
        }
      }

      // Lyrics
      const lyricsFontWeight = CONFIG.LYRICS_FONT_BOLD ? "bold" : "normal";
      ctx.font = `${lyricsFontWeight} ${CONFIG.LYRICS_FONT_SIZE}px system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans", Arial, sans-serif`;
      ctx.fillStyle = "#000";
      for(const l of letters){
        ctx.fillText(l.char, l.x, l.y);
      }

      // Finish message (displayed on character when game ends)
      if(state.dead){
        ctx.font = `bold ${CONFIG.FINISH_MESSAGE_FONT_SIZE}px Arial`;
        ctx.fillStyle = CONFIG.FINISH_MESSAGE_COLOR;
        ctx.textAlign = "center";
        ctx.textBaseline = "bottom";
        const msgX = dino.x + dino.w/2 + CONFIG.FINISH_MESSAGE_OFFSET_X;
        const msgY = dino.y + CONFIG.FINISH_MESSAGE_OFFSET_Y;
        ctx.fillText(CONFIG.FINISH_MESSAGE, msgX, msgY);
        ctx.textAlign = "left";
        ctx.textBaseline = "alphabetic";
      }
    }

    function drawLayer(tilesArray, prefix, id, fallbackAlpha, targetHeight, alreadyAdjusted){
      const key = `${prefix}${id}.png`;
      const e = imageCache.get(key) || loadImageOnce(key);

      // Adjust tiles once when image loads
      if(e.loaded && e.ok && !alreadyAdjusted){
        adjustLayerForImage(tilesArray, e.width, e.height, targetHeight);
        alreadyAdjusted = true;
      }

      for(const t of tilesArray){
        if(e.loaded && e.ok){
          ctx.drawImage(e.img, t.x, t.y, t.w, t.h);
        }else{
          // Fallback: yellow square with layer-specific alpha
          ctx.globalAlpha = fallbackAlpha;
          ctx.fillStyle = CONFIG.LAYER_FALLBACK_COLOR;
          const s = CONFIG.LAYER_FALLBACK_SIZE;
          const cx = t.x + (t.w - s)/2, cy = t.y + (t.h - s)/2;
          ctx.fillRect(cx, cy, s, s);
          ctx.globalAlpha = 1.0; // reset
        }
      }

      return alreadyAdjusted;
    }

    function drawDino(){
      const frame = Math.floor(state.animTime * 8) % 2;
      const key = `${CONFIG.DINO_PREFIX}${curDinoId}_${frame===0?"a":"b"}.png`;
      const e = imageCache.get(key) || loadImageOnce(key);
      if(e.loaded && e.ok){
        // Use original image size * scale
        const w = e.width * CONFIG.DINO_IMAGE_SCALE;
        const h = e.height * CONFIG.DINO_IMAGE_SCALE;
        ctx.drawImage(e.img, dino.x, dino.y, w, h);
      }else{
        // Fallback: use CONFIG size
        ctx.fillStyle = CONFIG.DINO_FALLBACK_COLOR;
        ctx.fillRect(dino.x, dino.y, dino.w, dino.h);
      }
    }

    function drawObstacle(ob){
      const isAir = !!ob.air;
      const key = isAir
        ? `${CONFIG.AOBST_PREFIX}${curAirId}.png`
        : `${CONFIG.OBST_PREFIX}${curGroundId}.png`;
      const e = imageCache.get(key) || loadImageOnce(key);
      if(e.loaded && e.ok){
        // Use original image size * scale (already calculated in spawn)
        ctx.drawImage(e.img, ob.x, ob.y, ob.w, ob.h);
      }else{
        // Fallback: use obstacle's stored size
        ctx.fillStyle = CONFIG.OBST_FALLBACK_COLOR;
        ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
      }
    }

    // ===============================
    // Boot
    // ===============================
    highScoreEl.textContent = `HIGH SCORE: ${state.highScore}`;
    scoreEl.textContent = `SCORE: 0`;
    resetGame();
  </script>
</body>
</html>